// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IGDBProtoFile.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proto_AgeRatingCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ageratingCategoryNull // = 0
  case esrb // = 1
  case pegi // = 2
  case cero // = 3
  case usk // = 4
  case grac // = 5
  case classInd // = 6
  case acb // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .ageratingCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ageratingCategoryNull
    case 1: self = .esrb
    case 2: self = .pegi
    case 3: self = .cero
    case 4: self = .usk
    case 5: self = .grac
    case 6: self = .classInd
    case 7: self = .acb
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ageratingCategoryNull: return 0
    case .esrb: return 1
    case .pegi: return 2
    case .cero: return 3
    case .usk: return 4
    case .grac: return 5
    case .classInd: return 6
    case .acb: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AgeRatingCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_AgeRatingCategoryEnum] = [
    .ageratingCategoryNull,
    .esrb,
    .pegi,
    .cero,
    .usk,
    .grac,
    .classInd,
    .acb,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_AgeRatingRatingEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ageratingRatingNull // = 0
  case three // = 1
  case seven // = 2
  case twelve // = 3
  case sixteen // = 4
  case eighteen // = 5
  case rp // = 6
  case ec // = 7
  case e // = 8
  case e10 // = 9
  case t // = 10
  case m // = 11
  case ao // = 12
  case ceroA // = 13
  case ceroB // = 14
  case ceroC // = 15
  case ceroD // = 16
  case ceroZ // = 17
  case usk0 // = 18
  case usk6 // = 19
  case usk12 // = 20
  case usk16 // = 21
  case usk18 // = 22
  case gracAll // = 23
  case gracTwelve // = 24
  case gracFifteen // = 25
  case gracEighteen // = 26
  case gracTesting // = 27
  case classIndL // = 28
  case classIndTen // = 29
  case classIndTwelve // = 30
  case classIndFourteen // = 31
  case classIndSixteen // = 32
  case classIndEighteen // = 33
  case acbG // = 34
  case acbPg // = 35
  case acbM // = 36
  case acbMa15 // = 37
  case acbR18 // = 38
  case acbRc // = 39
  case UNRECOGNIZED(Int)

  public init() {
    self = .ageratingRatingNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ageratingRatingNull
    case 1: self = .three
    case 2: self = .seven
    case 3: self = .twelve
    case 4: self = .sixteen
    case 5: self = .eighteen
    case 6: self = .rp
    case 7: self = .ec
    case 8: self = .e
    case 9: self = .e10
    case 10: self = .t
    case 11: self = .m
    case 12: self = .ao
    case 13: self = .ceroA
    case 14: self = .ceroB
    case 15: self = .ceroC
    case 16: self = .ceroD
    case 17: self = .ceroZ
    case 18: self = .usk0
    case 19: self = .usk6
    case 20: self = .usk12
    case 21: self = .usk16
    case 22: self = .usk18
    case 23: self = .gracAll
    case 24: self = .gracTwelve
    case 25: self = .gracFifteen
    case 26: self = .gracEighteen
    case 27: self = .gracTesting
    case 28: self = .classIndL
    case 29: self = .classIndTen
    case 30: self = .classIndTwelve
    case 31: self = .classIndFourteen
    case 32: self = .classIndSixteen
    case 33: self = .classIndEighteen
    case 34: self = .acbG
    case 35: self = .acbPg
    case 36: self = .acbM
    case 37: self = .acbMa15
    case 38: self = .acbR18
    case 39: self = .acbRc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ageratingRatingNull: return 0
    case .three: return 1
    case .seven: return 2
    case .twelve: return 3
    case .sixteen: return 4
    case .eighteen: return 5
    case .rp: return 6
    case .ec: return 7
    case .e: return 8
    case .e10: return 9
    case .t: return 10
    case .m: return 11
    case .ao: return 12
    case .ceroA: return 13
    case .ceroB: return 14
    case .ceroC: return 15
    case .ceroD: return 16
    case .ceroZ: return 17
    case .usk0: return 18
    case .usk6: return 19
    case .usk12: return 20
    case .usk16: return 21
    case .usk18: return 22
    case .gracAll: return 23
    case .gracTwelve: return 24
    case .gracFifteen: return 25
    case .gracEighteen: return 26
    case .gracTesting: return 27
    case .classIndL: return 28
    case .classIndTen: return 29
    case .classIndTwelve: return 30
    case .classIndFourteen: return 31
    case .classIndSixteen: return 32
    case .classIndEighteen: return 33
    case .acbG: return 34
    case .acbPg: return 35
    case .acbM: return 36
    case .acbMa15: return 37
    case .acbR18: return 38
    case .acbRc: return 39
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AgeRatingRatingEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_AgeRatingRatingEnum] = [
    .ageratingRatingNull,
    .three,
    .seven,
    .twelve,
    .sixteen,
    .eighteen,
    .rp,
    .ec,
    .e,
    .e10,
    .t,
    .m,
    .ao,
    .ceroA,
    .ceroB,
    .ceroC,
    .ceroD,
    .ceroZ,
    .usk0,
    .usk6,
    .usk12,
    .usk16,
    .usk18,
    .gracAll,
    .gracTwelve,
    .gracFifteen,
    .gracEighteen,
    .gracTesting,
    .classIndL,
    .classIndTen,
    .classIndTwelve,
    .classIndFourteen,
    .classIndSixteen,
    .classIndEighteen,
    .acbG,
    .acbPg,
    .acbM,
    .acbMa15,
    .acbR18,
    .acbRc,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_AgeRatingContentDescriptionCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ageratingcontentdescriptionCategoryNull // = 0
  case esrbAlcoholReference // = 1
  case esrbAnimatedBlood // = 2
  case esrbBlood // = 3
  case esrbBloodAndGore // = 4
  case esrbCartoonViolence // = 5
  case esrbComicMischief // = 6
  case esrbCrudeHumor // = 7
  case esrbDrugReference // = 8
  case esrbFantasyViolence // = 9
  case esrbIntenseViolence // = 10
  case esrbLanguage // = 11
  case esrbLyrics // = 12
  case esrbMatureHumor // = 13
  case esrbNudity // = 14
  case esrbPartialNudity // = 15
  case esrbRealGambling // = 16
  case esrbSexualContent // = 17
  case esrbSexualThemes // = 18
  case esrbSexualViolence // = 19
  case esrbSimulatedGambling // = 20
  case esrbStrongLanguage // = 21
  case esrbStrongLyrics // = 22
  case esrbStrongSexualContent // = 23
  case esrbSuggestiveThemes // = 24
  case esrbTobaccoReference // = 25
  case esrbUseOfAlcohol // = 26
  case esrbUseOfDrugs // = 27
  case esrbUseOfTobacco // = 28
  case esrbViolence // = 29
  case esrbViolentReferences // = 30
  case esrbAnimatedViolence // = 31
  case esrbMildLanguage // = 32
  case esrbMildViolence // = 33
  case esrbUseOfDrugsAndAlcohol // = 34
  case esrbDrugAndAlcoholReference // = 35
  case esrbMildSuggestiveThemes // = 36
  case esrbMildCartoonViolence // = 37
  case esrbMildBlood // = 38
  case esrbRealisticBloodAndGore // = 39
  case esrbRealisticViolence // = 40
  case esrbAlcoholAndTobaccoReference // = 41
  case esrbMatureSexualThemes // = 42
  case esrbMildAnimatedViolence // = 43
  case esrbMildSexualThemes // = 44
  case esrbUseOfAlcoholAndTobacco // = 45
  case esrbAnimatedBloodAndGore // = 46
  case esrbMildFantasyViolence // = 47
  case esrbMildLyrics // = 48
  case esrbRealisticBlood // = 49
  case pegiViolence // = 50
  case pegiSex // = 51
  case pegiDrugs // = 52
  case pegiFear // = 53
  case pegiDiscrimination // = 54
  case pegiBadLanguage // = 55
  case pegiGambling // = 56
  case pegiOnlineGameplay // = 57
  case pegiInGamePurchases // = 58
  case ceroLove // = 59
  case ceroSexualContent // = 60
  case ceroViolence // = 61
  case ceroHorror // = 62
  case ceroDrinkingSmoking // = 63
  case ceroGambling // = 64
  case ceroCrime // = 65
  case ceroControlledSubstances // = 66
  case ceroLanguagesAndOthers // = 67
  case gracSexuality // = 68
  case gracViolence // = 69
  case gracFearHorrorThreatening // = 70
  case gracLanguage // = 71
  case gracAlcoholTobaccoDrug // = 72
  case gracCrimeAntiSocial // = 73
  case gracGambling // = 74
  case classIndViolencia // = 75
  case classIndViolenciaExtrema // = 76
  case classIndConteudoSexual // = 77
  case classIndNudez // = 78
  case classIndSexo // = 79
  case classIndSexoExplicito // = 80
  case classIndDrogas // = 81
  case classIndDrogasLicitas // = 82
  case classIndDrogasIlicitas // = 83
  case classIndLinguagemImpropria // = 84
  case classIndAtosCriminosos // = 85
  case UNRECOGNIZED(Int)

  public init() {
    self = .ageratingcontentdescriptionCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ageratingcontentdescriptionCategoryNull
    case 1: self = .esrbAlcoholReference
    case 2: self = .esrbAnimatedBlood
    case 3: self = .esrbBlood
    case 4: self = .esrbBloodAndGore
    case 5: self = .esrbCartoonViolence
    case 6: self = .esrbComicMischief
    case 7: self = .esrbCrudeHumor
    case 8: self = .esrbDrugReference
    case 9: self = .esrbFantasyViolence
    case 10: self = .esrbIntenseViolence
    case 11: self = .esrbLanguage
    case 12: self = .esrbLyrics
    case 13: self = .esrbMatureHumor
    case 14: self = .esrbNudity
    case 15: self = .esrbPartialNudity
    case 16: self = .esrbRealGambling
    case 17: self = .esrbSexualContent
    case 18: self = .esrbSexualThemes
    case 19: self = .esrbSexualViolence
    case 20: self = .esrbSimulatedGambling
    case 21: self = .esrbStrongLanguage
    case 22: self = .esrbStrongLyrics
    case 23: self = .esrbStrongSexualContent
    case 24: self = .esrbSuggestiveThemes
    case 25: self = .esrbTobaccoReference
    case 26: self = .esrbUseOfAlcohol
    case 27: self = .esrbUseOfDrugs
    case 28: self = .esrbUseOfTobacco
    case 29: self = .esrbViolence
    case 30: self = .esrbViolentReferences
    case 31: self = .esrbAnimatedViolence
    case 32: self = .esrbMildLanguage
    case 33: self = .esrbMildViolence
    case 34: self = .esrbUseOfDrugsAndAlcohol
    case 35: self = .esrbDrugAndAlcoholReference
    case 36: self = .esrbMildSuggestiveThemes
    case 37: self = .esrbMildCartoonViolence
    case 38: self = .esrbMildBlood
    case 39: self = .esrbRealisticBloodAndGore
    case 40: self = .esrbRealisticViolence
    case 41: self = .esrbAlcoholAndTobaccoReference
    case 42: self = .esrbMatureSexualThemes
    case 43: self = .esrbMildAnimatedViolence
    case 44: self = .esrbMildSexualThemes
    case 45: self = .esrbUseOfAlcoholAndTobacco
    case 46: self = .esrbAnimatedBloodAndGore
    case 47: self = .esrbMildFantasyViolence
    case 48: self = .esrbMildLyrics
    case 49: self = .esrbRealisticBlood
    case 50: self = .pegiViolence
    case 51: self = .pegiSex
    case 52: self = .pegiDrugs
    case 53: self = .pegiFear
    case 54: self = .pegiDiscrimination
    case 55: self = .pegiBadLanguage
    case 56: self = .pegiGambling
    case 57: self = .pegiOnlineGameplay
    case 58: self = .pegiInGamePurchases
    case 59: self = .ceroLove
    case 60: self = .ceroSexualContent
    case 61: self = .ceroViolence
    case 62: self = .ceroHorror
    case 63: self = .ceroDrinkingSmoking
    case 64: self = .ceroGambling
    case 65: self = .ceroCrime
    case 66: self = .ceroControlledSubstances
    case 67: self = .ceroLanguagesAndOthers
    case 68: self = .gracSexuality
    case 69: self = .gracViolence
    case 70: self = .gracFearHorrorThreatening
    case 71: self = .gracLanguage
    case 72: self = .gracAlcoholTobaccoDrug
    case 73: self = .gracCrimeAntiSocial
    case 74: self = .gracGambling
    case 75: self = .classIndViolencia
    case 76: self = .classIndViolenciaExtrema
    case 77: self = .classIndConteudoSexual
    case 78: self = .classIndNudez
    case 79: self = .classIndSexo
    case 80: self = .classIndSexoExplicito
    case 81: self = .classIndDrogas
    case 82: self = .classIndDrogasLicitas
    case 83: self = .classIndDrogasIlicitas
    case 84: self = .classIndLinguagemImpropria
    case 85: self = .classIndAtosCriminosos
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ageratingcontentdescriptionCategoryNull: return 0
    case .esrbAlcoholReference: return 1
    case .esrbAnimatedBlood: return 2
    case .esrbBlood: return 3
    case .esrbBloodAndGore: return 4
    case .esrbCartoonViolence: return 5
    case .esrbComicMischief: return 6
    case .esrbCrudeHumor: return 7
    case .esrbDrugReference: return 8
    case .esrbFantasyViolence: return 9
    case .esrbIntenseViolence: return 10
    case .esrbLanguage: return 11
    case .esrbLyrics: return 12
    case .esrbMatureHumor: return 13
    case .esrbNudity: return 14
    case .esrbPartialNudity: return 15
    case .esrbRealGambling: return 16
    case .esrbSexualContent: return 17
    case .esrbSexualThemes: return 18
    case .esrbSexualViolence: return 19
    case .esrbSimulatedGambling: return 20
    case .esrbStrongLanguage: return 21
    case .esrbStrongLyrics: return 22
    case .esrbStrongSexualContent: return 23
    case .esrbSuggestiveThemes: return 24
    case .esrbTobaccoReference: return 25
    case .esrbUseOfAlcohol: return 26
    case .esrbUseOfDrugs: return 27
    case .esrbUseOfTobacco: return 28
    case .esrbViolence: return 29
    case .esrbViolentReferences: return 30
    case .esrbAnimatedViolence: return 31
    case .esrbMildLanguage: return 32
    case .esrbMildViolence: return 33
    case .esrbUseOfDrugsAndAlcohol: return 34
    case .esrbDrugAndAlcoholReference: return 35
    case .esrbMildSuggestiveThemes: return 36
    case .esrbMildCartoonViolence: return 37
    case .esrbMildBlood: return 38
    case .esrbRealisticBloodAndGore: return 39
    case .esrbRealisticViolence: return 40
    case .esrbAlcoholAndTobaccoReference: return 41
    case .esrbMatureSexualThemes: return 42
    case .esrbMildAnimatedViolence: return 43
    case .esrbMildSexualThemes: return 44
    case .esrbUseOfAlcoholAndTobacco: return 45
    case .esrbAnimatedBloodAndGore: return 46
    case .esrbMildFantasyViolence: return 47
    case .esrbMildLyrics: return 48
    case .esrbRealisticBlood: return 49
    case .pegiViolence: return 50
    case .pegiSex: return 51
    case .pegiDrugs: return 52
    case .pegiFear: return 53
    case .pegiDiscrimination: return 54
    case .pegiBadLanguage: return 55
    case .pegiGambling: return 56
    case .pegiOnlineGameplay: return 57
    case .pegiInGamePurchases: return 58
    case .ceroLove: return 59
    case .ceroSexualContent: return 60
    case .ceroViolence: return 61
    case .ceroHorror: return 62
    case .ceroDrinkingSmoking: return 63
    case .ceroGambling: return 64
    case .ceroCrime: return 65
    case .ceroControlledSubstances: return 66
    case .ceroLanguagesAndOthers: return 67
    case .gracSexuality: return 68
    case .gracViolence: return 69
    case .gracFearHorrorThreatening: return 70
    case .gracLanguage: return 71
    case .gracAlcoholTobaccoDrug: return 72
    case .gracCrimeAntiSocial: return 73
    case .gracGambling: return 74
    case .classIndViolencia: return 75
    case .classIndViolenciaExtrema: return 76
    case .classIndConteudoSexual: return 77
    case .classIndNudez: return 78
    case .classIndSexo: return 79
    case .classIndSexoExplicito: return 80
    case .classIndDrogas: return 81
    case .classIndDrogasLicitas: return 82
    case .classIndDrogasIlicitas: return 83
    case .classIndLinguagemImpropria: return 84
    case .classIndAtosCriminosos: return 85
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AgeRatingContentDescriptionCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_AgeRatingContentDescriptionCategoryEnum] = [
    .ageratingcontentdescriptionCategoryNull,
    .esrbAlcoholReference,
    .esrbAnimatedBlood,
    .esrbBlood,
    .esrbBloodAndGore,
    .esrbCartoonViolence,
    .esrbComicMischief,
    .esrbCrudeHumor,
    .esrbDrugReference,
    .esrbFantasyViolence,
    .esrbIntenseViolence,
    .esrbLanguage,
    .esrbLyrics,
    .esrbMatureHumor,
    .esrbNudity,
    .esrbPartialNudity,
    .esrbRealGambling,
    .esrbSexualContent,
    .esrbSexualThemes,
    .esrbSexualViolence,
    .esrbSimulatedGambling,
    .esrbStrongLanguage,
    .esrbStrongLyrics,
    .esrbStrongSexualContent,
    .esrbSuggestiveThemes,
    .esrbTobaccoReference,
    .esrbUseOfAlcohol,
    .esrbUseOfDrugs,
    .esrbUseOfTobacco,
    .esrbViolence,
    .esrbViolentReferences,
    .esrbAnimatedViolence,
    .esrbMildLanguage,
    .esrbMildViolence,
    .esrbUseOfDrugsAndAlcohol,
    .esrbDrugAndAlcoholReference,
    .esrbMildSuggestiveThemes,
    .esrbMildCartoonViolence,
    .esrbMildBlood,
    .esrbRealisticBloodAndGore,
    .esrbRealisticViolence,
    .esrbAlcoholAndTobaccoReference,
    .esrbMatureSexualThemes,
    .esrbMildAnimatedViolence,
    .esrbMildSexualThemes,
    .esrbUseOfAlcoholAndTobacco,
    .esrbAnimatedBloodAndGore,
    .esrbMildFantasyViolence,
    .esrbMildLyrics,
    .esrbRealisticBlood,
    .pegiViolence,
    .pegiSex,
    .pegiDrugs,
    .pegiFear,
    .pegiDiscrimination,
    .pegiBadLanguage,
    .pegiGambling,
    .pegiOnlineGameplay,
    .pegiInGamePurchases,
    .ceroLove,
    .ceroSexualContent,
    .ceroViolence,
    .ceroHorror,
    .ceroDrinkingSmoking,
    .ceroGambling,
    .ceroCrime,
    .ceroControlledSubstances,
    .ceroLanguagesAndOthers,
    .gracSexuality,
    .gracViolence,
    .gracFearHorrorThreatening,
    .gracLanguage,
    .gracAlcoholTobaccoDrug,
    .gracCrimeAntiSocial,
    .gracGambling,
    .classIndViolencia,
    .classIndViolenciaExtrema,
    .classIndConteudoSexual,
    .classIndNudez,
    .classIndSexo,
    .classIndSexoExplicito,
    .classIndDrogas,
    .classIndDrogasLicitas,
    .classIndDrogasIlicitas,
    .classIndLinguagemImpropria,
    .classIndAtosCriminosos,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GenderGenderEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case male // = 0
  case female // = 1
  case other // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .male
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .male
    case 1: self = .female
    case 2: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .male: return 0
    case .female: return 1
    case .other: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GenderGenderEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GenderGenderEnum] = [
    .male,
    .female,
    .other,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_CharacterSpeciesEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case characterSpeciesNull // = 0
  case human // = 1
  case alien // = 2
  case animal // = 3
  case android // = 4
  case unknown // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .characterSpeciesNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .characterSpeciesNull
    case 1: self = .human
    case 2: self = .alien
    case 3: self = .animal
    case 4: self = .android
    case 5: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .characterSpeciesNull: return 0
    case .human: return 1
    case .alien: return 2
    case .animal: return 3
    case .android: return 4
    case .unknown: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_CharacterSpeciesEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_CharacterSpeciesEnum] = [
    .characterSpeciesNull,
    .human,
    .alien,
    .animal,
    .android,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_DateFormatChangeDateCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case yyyymmmmdd // = 0
  case yyyymmmm // = 1
  case yyyy // = 2
  case yyyyq1 // = 3
  case yyyyq2 // = 4
  case yyyyq3 // = 5
  case yyyyq4 // = 6
  case tbd // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .yyyymmmmdd
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .yyyymmmmdd
    case 1: self = .yyyymmmm
    case 2: self = .yyyy
    case 3: self = .yyyyq1
    case 4: self = .yyyyq2
    case 5: self = .yyyyq3
    case 6: self = .yyyyq4
    case 7: self = .tbd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .yyyymmmmdd: return 0
    case .yyyymmmm: return 1
    case .yyyy: return 2
    case .yyyyq1: return 3
    case .yyyyq2: return 4
    case .yyyyq3: return 5
    case .yyyyq4: return 6
    case .tbd: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DateFormatChangeDateCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_DateFormatChangeDateCategoryEnum] = [
    .yyyymmmmdd,
    .yyyymmmm,
    .yyyy,
    .yyyyq1,
    .yyyyq2,
    .yyyyq3,
    .yyyyq4,
    .tbd,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_WebsiteCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case websiteCategoryNull // = 0
  case websiteOfficial // = 1
  case websiteWikia // = 2
  case websiteWikipedia // = 3
  case websiteFacebook // = 4
  case websiteTwitter // = 5
  case websiteTwitch // = 6
  case websiteInstagram // = 8
  case websiteYoutube // = 9
  case websiteIphone // = 10
  case websiteIpad // = 11
  case websiteAndroid // = 12
  case websiteSteam // = 13
  case websiteReddit // = 14
  case websiteItch // = 15
  case websiteEpicgames // = 16
  case websiteGog // = 17
  case websiteDiscord // = 18
  case UNRECOGNIZED(Int)

  public init() {
    self = .websiteCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .websiteCategoryNull
    case 1: self = .websiteOfficial
    case 2: self = .websiteWikia
    case 3: self = .websiteWikipedia
    case 4: self = .websiteFacebook
    case 5: self = .websiteTwitter
    case 6: self = .websiteTwitch
    case 8: self = .websiteInstagram
    case 9: self = .websiteYoutube
    case 10: self = .websiteIphone
    case 11: self = .websiteIpad
    case 12: self = .websiteAndroid
    case 13: self = .websiteSteam
    case 14: self = .websiteReddit
    case 15: self = .websiteItch
    case 16: self = .websiteEpicgames
    case 17: self = .websiteGog
    case 18: self = .websiteDiscord
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .websiteCategoryNull: return 0
    case .websiteOfficial: return 1
    case .websiteWikia: return 2
    case .websiteWikipedia: return 3
    case .websiteFacebook: return 4
    case .websiteTwitter: return 5
    case .websiteTwitch: return 6
    case .websiteInstagram: return 8
    case .websiteYoutube: return 9
    case .websiteIphone: return 10
    case .websiteIpad: return 11
    case .websiteAndroid: return 12
    case .websiteSteam: return 13
    case .websiteReddit: return 14
    case .websiteItch: return 15
    case .websiteEpicgames: return 16
    case .websiteGog: return 17
    case .websiteDiscord: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_WebsiteCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_WebsiteCategoryEnum] = [
    .websiteCategoryNull,
    .websiteOfficial,
    .websiteWikia,
    .websiteWikipedia,
    .websiteFacebook,
    .websiteTwitter,
    .websiteTwitch,
    .websiteInstagram,
    .websiteYoutube,
    .websiteIphone,
    .websiteIpad,
    .websiteAndroid,
    .websiteSteam,
    .websiteReddit,
    .websiteItch,
    .websiteEpicgames,
    .websiteGog,
    .websiteDiscord,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_ExternalGameCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case externalgameCategoryNull // = 0
  case externalgameSteam // = 1
  case externalgameGog // = 5
  case externalgameYoutube // = 10
  case externalgameMicrosoft // = 11
  case externalgameApple // = 13
  case externalgameTwitch // = 14
  case externalgameAndroid // = 15
  case externalgameAmazonAsin // = 20
  case externalgameAmazonLuna // = 22
  case externalgameAmazonAdg // = 23
  case externalgameEpicGameStore // = 26
  case externalgameOculus // = 28
  case externalgameUtomik // = 29
  case externalgameItchIo // = 30
  case externalgameXboxMarketplace // = 31
  case externalgameKartridge // = 32
  case externalgamePlaystationStoreUs // = 36
  case externalgameFocusEntertainment // = 37
  case externalgameXboxGamePassUltimateCloud // = 54
  case externalgameGamejolt // = 55
  case UNRECOGNIZED(Int)

  public init() {
    self = .externalgameCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .externalgameCategoryNull
    case 1: self = .externalgameSteam
    case 5: self = .externalgameGog
    case 10: self = .externalgameYoutube
    case 11: self = .externalgameMicrosoft
    case 13: self = .externalgameApple
    case 14: self = .externalgameTwitch
    case 15: self = .externalgameAndroid
    case 20: self = .externalgameAmazonAsin
    case 22: self = .externalgameAmazonLuna
    case 23: self = .externalgameAmazonAdg
    case 26: self = .externalgameEpicGameStore
    case 28: self = .externalgameOculus
    case 29: self = .externalgameUtomik
    case 30: self = .externalgameItchIo
    case 31: self = .externalgameXboxMarketplace
    case 32: self = .externalgameKartridge
    case 36: self = .externalgamePlaystationStoreUs
    case 37: self = .externalgameFocusEntertainment
    case 54: self = .externalgameXboxGamePassUltimateCloud
    case 55: self = .externalgameGamejolt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .externalgameCategoryNull: return 0
    case .externalgameSteam: return 1
    case .externalgameGog: return 5
    case .externalgameYoutube: return 10
    case .externalgameMicrosoft: return 11
    case .externalgameApple: return 13
    case .externalgameTwitch: return 14
    case .externalgameAndroid: return 15
    case .externalgameAmazonAsin: return 20
    case .externalgameAmazonLuna: return 22
    case .externalgameAmazonAdg: return 23
    case .externalgameEpicGameStore: return 26
    case .externalgameOculus: return 28
    case .externalgameUtomik: return 29
    case .externalgameItchIo: return 30
    case .externalgameXboxMarketplace: return 31
    case .externalgameKartridge: return 32
    case .externalgamePlaystationStoreUs: return 36
    case .externalgameFocusEntertainment: return 37
    case .externalgameXboxGamePassUltimateCloud: return 54
    case .externalgameGamejolt: return 55
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ExternalGameCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_ExternalGameCategoryEnum] = [
    .externalgameCategoryNull,
    .externalgameSteam,
    .externalgameGog,
    .externalgameYoutube,
    .externalgameMicrosoft,
    .externalgameApple,
    .externalgameTwitch,
    .externalgameAndroid,
    .externalgameAmazonAsin,
    .externalgameAmazonLuna,
    .externalgameAmazonAdg,
    .externalgameEpicGameStore,
    .externalgameOculus,
    .externalgameUtomik,
    .externalgameItchIo,
    .externalgameXboxMarketplace,
    .externalgameKartridge,
    .externalgamePlaystationStoreUs,
    .externalgameFocusEntertainment,
    .externalgameXboxGamePassUltimateCloud,
    .externalgameGamejolt,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_ExternalGameMediaEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case externalgameMediaNull // = 0
  case externalgameDigital // = 1
  case externalgamePhysical // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .externalgameMediaNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .externalgameMediaNull
    case 1: self = .externalgameDigital
    case 2: self = .externalgamePhysical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .externalgameMediaNull: return 0
    case .externalgameDigital: return 1
    case .externalgamePhysical: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ExternalGameMediaEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_ExternalGameMediaEnum] = [
    .externalgameMediaNull,
    .externalgameDigital,
    .externalgamePhysical,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case mainGame // = 0
  case dlcAddon // = 1
  case expansion // = 2
  case bundle // = 3
  case standaloneExpansion // = 4
  case mod // = 5
  case episode // = 6
  case season // = 7
  case remake // = 8
  case remaster // = 9
  case expandedGame // = 10
  case port // = 11
  case fork // = 12
  case pack // = 13
  case update // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .mainGame
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mainGame
    case 1: self = .dlcAddon
    case 2: self = .expansion
    case 3: self = .bundle
    case 4: self = .standaloneExpansion
    case 5: self = .mod
    case 6: self = .episode
    case 7: self = .season
    case 8: self = .remake
    case 9: self = .remaster
    case 10: self = .expandedGame
    case 11: self = .port
    case 12: self = .fork
    case 13: self = .pack
    case 14: self = .update
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mainGame: return 0
    case .dlcAddon: return 1
    case .expansion: return 2
    case .bundle: return 3
    case .standaloneExpansion: return 4
    case .mod: return 5
    case .episode: return 6
    case .season: return 7
    case .remake: return 8
    case .remaster: return 9
    case .expandedGame: return 10
    case .port: return 11
    case .fork: return 12
    case .pack: return 13
    case .update: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameCategoryEnum] = [
    .mainGame,
    .dlcAddon,
    .expansion,
    .bundle,
    .standaloneExpansion,
    .mod,
    .episode,
    .season,
    .remake,
    .remaster,
    .expandedGame,
    .port,
    .fork,
    .pack,
    .update,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameStatusEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case released // = 0
  case alpha // = 2
  case beta // = 3
  case earlyAccess // = 4
  case offline // = 5
  case cancelled // = 6
  case rumored // = 7
  case delisted // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .released
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .released
    case 2: self = .alpha
    case 3: self = .beta
    case 4: self = .earlyAccess
    case 5: self = .offline
    case 6: self = .cancelled
    case 7: self = .rumored
    case 8: self = .delisted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .released: return 0
    case .alpha: return 2
    case .beta: return 3
    case .earlyAccess: return 4
    case .offline: return 5
    case .cancelled: return 6
    case .rumored: return 7
    case .delisted: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameStatusEnum] = [
    .released,
    .alpha,
    .beta,
    .earlyAccess,
    .offline,
    .cancelled,
    .rumored,
    .delisted,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameVersionFeatureCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case boolean // = 0
  case description_ // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .boolean
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .boolean
    case 1: self = .description_
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .boolean: return 0
    case .description_: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameVersionFeatureCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameVersionFeatureCategoryEnum] = [
    .boolean,
    .description_,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameVersionFeatureValueIncludedFeatureEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notIncluded // = 0
  case included // = 1
  case preOrderOnly // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notIncluded
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notIncluded
    case 1: self = .included
    case 2: self = .preOrderOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notIncluded: return 0
    case .included: return 1
    case .preOrderOnly: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameVersionFeatureValueIncludedFeatureEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameVersionFeatureValueIncludedFeatureEnum] = [
    .notIncluded,
    .included,
    .preOrderOnly,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_PlatformCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case platformCategoryNull // = 0
  case console // = 1
  case arcade // = 2
  case platform // = 3
  case operatingSystem // = 4
  case portableConsole // = 5
  case computer // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .platformCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .platformCategoryNull
    case 1: self = .console
    case 2: self = .arcade
    case 3: self = .platform
    case 4: self = .operatingSystem
    case 5: self = .portableConsole
    case 6: self = .computer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .platformCategoryNull: return 0
    case .console: return 1
    case .arcade: return 2
    case .platform: return 3
    case .operatingSystem: return 4
    case .portableConsole: return 5
    case .computer: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_PlatformCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_PlatformCategoryEnum] = [
    .platformCategoryNull,
    .console,
    .arcade,
    .platform,
    .operatingSystem,
    .portableConsole,
    .computer,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_RegionRegionEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case regionRegionNull // = 0
  case europe // = 1
  case northAmerica // = 2
  case australia // = 3
  case newZealand // = 4
  case japan // = 5
  case china // = 6
  case asia // = 7
  case worldwide // = 8
  case korea // = 9
  case brazil // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .regionRegionNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .regionRegionNull
    case 1: self = .europe
    case 2: self = .northAmerica
    case 3: self = .australia
    case 4: self = .newZealand
    case 5: self = .japan
    case 6: self = .china
    case 7: self = .asia
    case 8: self = .worldwide
    case 9: self = .korea
    case 10: self = .brazil
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .regionRegionNull: return 0
    case .europe: return 1
    case .northAmerica: return 2
    case .australia: return 3
    case .newZealand: return 4
    case .japan: return 5
    case .china: return 6
    case .asia: return 7
    case .worldwide: return 8
    case .korea: return 9
    case .brazil: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_RegionRegionEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_RegionRegionEnum] = [
    .regionRegionNull,
    .europe,
    .northAmerica,
    .australia,
    .newZealand,
    .japan,
    .china,
    .asia,
    .worldwide,
    .korea,
    .brazil,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_TestDummyEnumTestEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case testdummyEnumTestNull // = 0
  case enum1 // = 1
  case enum2 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .testdummyEnumTestNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .testdummyEnumTestNull
    case 1: self = .enum1
    case 2: self = .enum2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .testdummyEnumTestNull: return 0
    case .enum1: return 1
    case .enum2: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TestDummyEnumTestEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TestDummyEnumTestEnum] = [
    .testdummyEnumTestNull,
    .enum1,
    .enum2,
  ]
}

#endif  // swift(>=4.2)

public struct Proto_Count {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiQueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var results: [Data] = []

  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiQueryResultArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: [Proto_MultiQueryResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ageratings: [Proto_AgeRating] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRating {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_AgeRatingCategoryEnum = .ageratingCategoryNull

  public var contentDescriptions: [Proto_AgeRatingContentDescription] = []

  public var rating: Proto_AgeRatingRatingEnum = .ageratingRatingNull

  public var ratingCoverURL: String = String()

  public var synopsis: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingContentDescriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ageratingcontentdescriptions: [Proto_AgeRatingContentDescription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingContentDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_AgeRatingContentDescriptionCategoryEnum = .ageratingcontentdescriptionCategoryNull

  public var description_p: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AlternativeNameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alternativenames: [Proto_AlternativeName] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AlternativeName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var comment: String = String()

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_ArtworkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artworks: [Proto_Artwork] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Artwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_CharacterResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var characters: [Proto_Character] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Character {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var akas: [String] {
    get {return _storage._akas}
    set {_uniqueStorage()._akas = newValue}
  }

  public var countryName: String {
    get {return _storage._countryName}
    set {_uniqueStorage()._countryName = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var games: [Proto_Game] {
    get {return _storage._games}
    set {_uniqueStorage()._games = newValue}
  }

  public var gender: Proto_GenderGenderEnum {
    get {return _storage._gender}
    set {_uniqueStorage()._gender = newValue}
  }

  public var mugShot: Proto_CharacterMugShot {
    get {return _storage._mugShot ?? Proto_CharacterMugShot()}
    set {_uniqueStorage()._mugShot = newValue}
  }
  /// Returns true if `mugShot` has been explicitly set.
  public var hasMugShot: Bool {return _storage._mugShot != nil}
  /// Clears the value of `mugShot`. Subsequent reads from it will return its default value.
  public mutating func clearMugShot() {_uniqueStorage()._mugShot = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var species: Proto_CharacterSpeciesEnum {
    get {return _storage._species}
    set {_uniqueStorage()._species = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_CharacterMugShotResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charactermugshots: [Proto_CharacterMugShot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CharacterMugShot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CollectionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var collections: [Proto_Collection] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Collection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var games: [Proto_Game] = []

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_CompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companies: [Proto_Company] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Company {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var changeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._changeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._changeDate = newValue}
  }
  /// Returns true if `changeDate` has been explicitly set.
  public var hasChangeDate: Bool {return _storage._changeDate != nil}
  /// Clears the value of `changeDate`. Subsequent reads from it will return its default value.
  public mutating func clearChangeDate() {_uniqueStorage()._changeDate = nil}

  public var changeDateCategory: Proto_DateFormatChangeDateCategoryEnum {
    get {return _storage._changeDateCategory}
    set {_uniqueStorage()._changeDateCategory = newValue}
  }

  public var changedCompanyID: Proto_Company {
    get {return _storage._changedCompanyID ?? Proto_Company()}
    set {_uniqueStorage()._changedCompanyID = newValue}
  }
  /// Returns true if `changedCompanyID` has been explicitly set.
  public var hasChangedCompanyID: Bool {return _storage._changedCompanyID != nil}
  /// Clears the value of `changedCompanyID`. Subsequent reads from it will return its default value.
  public mutating func clearChangedCompanyID() {_uniqueStorage()._changedCompanyID = nil}

  public var country: Int32 {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var developed: [Proto_Game] {
    get {return _storage._developed}
    set {_uniqueStorage()._developed = newValue}
  }

  public var logo: Proto_CompanyLogo {
    get {return _storage._logo ?? Proto_CompanyLogo()}
    set {_uniqueStorage()._logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return _storage._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {_uniqueStorage()._logo = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var parent: Proto_Company {
    get {return _storage._parent ?? Proto_Company()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {_uniqueStorage()._parent = nil}

  public var published: [Proto_Game] {
    get {return _storage._published}
    set {_uniqueStorage()._published = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  public var startDateCategory: Proto_DateFormatChangeDateCategoryEnum {
    get {return _storage._startDateCategory}
    set {_uniqueStorage()._startDateCategory = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var websites: [Proto_CompanyWebsite] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_CompanyLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companylogos: [Proto_CompanyLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyWebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companywebsites: [Proto_CompanyWebsite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyWebsite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CoverResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var covers: [Proto_Cover] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Cover {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var alphaChannel: Bool {
    get {return _storage._alphaChannel}
    set {_uniqueStorage()._alphaChannel = newValue}
  }

  public var animated: Bool {
    get {return _storage._animated}
    set {_uniqueStorage()._animated = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var imageID: String {
    get {return _storage._imageID}
    set {_uniqueStorage()._imageID = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var width: Int32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var gameLocalization: Proto_GameLocalization {
    get {return _storage._gameLocalization ?? Proto_GameLocalization()}
    set {_uniqueStorage()._gameLocalization = newValue}
  }
  /// Returns true if `gameLocalization` has been explicitly set.
  public var hasGameLocalization: Bool {return _storage._gameLocalization != nil}
  /// Clears the value of `gameLocalization`. Subsequent reads from it will return its default value.
  public mutating func clearGameLocalization() {_uniqueStorage()._gameLocalization = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_ExternalGameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var externalgames: [Proto_ExternalGame] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ExternalGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_ExternalGameCategoryEnum = .externalgameCategoryNull

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var uid: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var year: Int32 = 0

  public var media: Proto_ExternalGameMediaEnum = .externalgameMediaNull

  public var platform: Proto_Platform {
    get {return _platform ?? Proto_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var countries: [Int32] = []

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _platform: Proto_Platform? = nil
}

public struct Proto_FranchiseResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var franchises: [Proto_Franchise] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Franchise {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var games: [Proto_Game] = []

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var games: [Proto_Game] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Game {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var ageRatings: [Proto_AgeRating] {
    get {return _storage._ageRatings}
    set {_uniqueStorage()._ageRatings = newValue}
  }

  public var aggregatedRating: Double {
    get {return _storage._aggregatedRating}
    set {_uniqueStorage()._aggregatedRating = newValue}
  }

  public var aggregatedRatingCount: Int32 {
    get {return _storage._aggregatedRatingCount}
    set {_uniqueStorage()._aggregatedRatingCount = newValue}
  }

  public var alternativeNames: [Proto_AlternativeName] {
    get {return _storage._alternativeNames}
    set {_uniqueStorage()._alternativeNames = newValue}
  }

  public var artworks: [Proto_Artwork] {
    get {return _storage._artworks}
    set {_uniqueStorage()._artworks = newValue}
  }

  public var bundles: [Proto_Game] {
    get {return _storage._bundles}
    set {_uniqueStorage()._bundles = newValue}
  }

  public var category: Proto_GameCategoryEnum {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var collection: Proto_Collection {
    get {return _storage._collection ?? Proto_Collection()}
    set {_uniqueStorage()._collection = newValue}
  }
  /// Returns true if `collection` has been explicitly set.
  public var hasCollection: Bool {return _storage._collection != nil}
  /// Clears the value of `collection`. Subsequent reads from it will return its default value.
  public mutating func clearCollection() {_uniqueStorage()._collection = nil}

  public var cover: Proto_Cover {
    get {return _storage._cover ?? Proto_Cover()}
    set {_uniqueStorage()._cover = newValue}
  }
  /// Returns true if `cover` has been explicitly set.
  public var hasCover: Bool {return _storage._cover != nil}
  /// Clears the value of `cover`. Subsequent reads from it will return its default value.
  public mutating func clearCover() {_uniqueStorage()._cover = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var dlcs: [Proto_Game] {
    get {return _storage._dlcs}
    set {_uniqueStorage()._dlcs = newValue}
  }

  public var expansions: [Proto_Game] {
    get {return _storage._expansions}
    set {_uniqueStorage()._expansions = newValue}
  }

  public var externalGames: [Proto_ExternalGame] {
    get {return _storage._externalGames}
    set {_uniqueStorage()._externalGames = newValue}
  }

  public var firstReleaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstReleaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstReleaseDate = newValue}
  }
  /// Returns true if `firstReleaseDate` has been explicitly set.
  public var hasFirstReleaseDate: Bool {return _storage._firstReleaseDate != nil}
  /// Clears the value of `firstReleaseDate`. Subsequent reads from it will return its default value.
  public mutating func clearFirstReleaseDate() {_uniqueStorage()._firstReleaseDate = nil}

  public var follows: Int32 {
    get {return _storage._follows}
    set {_uniqueStorage()._follows = newValue}
  }

  public var franchise: Proto_Franchise {
    get {return _storage._franchise ?? Proto_Franchise()}
    set {_uniqueStorage()._franchise = newValue}
  }
  /// Returns true if `franchise` has been explicitly set.
  public var hasFranchise: Bool {return _storage._franchise != nil}
  /// Clears the value of `franchise`. Subsequent reads from it will return its default value.
  public mutating func clearFranchise() {_uniqueStorage()._franchise = nil}

  public var franchises: [Proto_Franchise] {
    get {return _storage._franchises}
    set {_uniqueStorage()._franchises = newValue}
  }

  public var gameEngines: [Proto_GameEngine] {
    get {return _storage._gameEngines}
    set {_uniqueStorage()._gameEngines = newValue}
  }

  public var gameModes: [Proto_GameMode] {
    get {return _storage._gameModes}
    set {_uniqueStorage()._gameModes = newValue}
  }

  public var genres: [Proto_Genre] {
    get {return _storage._genres}
    set {_uniqueStorage()._genres = newValue}
  }

  public var hypes: Int32 {
    get {return _storage._hypes}
    set {_uniqueStorage()._hypes = newValue}
  }

  public var involvedCompanies: [Proto_InvolvedCompany] {
    get {return _storage._involvedCompanies}
    set {_uniqueStorage()._involvedCompanies = newValue}
  }

  public var keywords: [Proto_Keyword] {
    get {return _storage._keywords}
    set {_uniqueStorage()._keywords = newValue}
  }

  public var multiplayerModes: [Proto_MultiplayerMode] {
    get {return _storage._multiplayerModes}
    set {_uniqueStorage()._multiplayerModes = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var parentGame: Proto_Game {
    get {return _storage._parentGame ?? Proto_Game()}
    set {_uniqueStorage()._parentGame = newValue}
  }
  /// Returns true if `parentGame` has been explicitly set.
  public var hasParentGame: Bool {return _storage._parentGame != nil}
  /// Clears the value of `parentGame`. Subsequent reads from it will return its default value.
  public mutating func clearParentGame() {_uniqueStorage()._parentGame = nil}

  public var platforms: [Proto_Platform] {
    get {return _storage._platforms}
    set {_uniqueStorage()._platforms = newValue}
  }

  public var playerPerspectives: [Proto_PlayerPerspective] {
    get {return _storage._playerPerspectives}
    set {_uniqueStorage()._playerPerspectives = newValue}
  }

  public var rating: Double {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  public var ratingCount: Int32 {
    get {return _storage._ratingCount}
    set {_uniqueStorage()._ratingCount = newValue}
  }

  public var releaseDates: [Proto_ReleaseDate] {
    get {return _storage._releaseDates}
    set {_uniqueStorage()._releaseDates = newValue}
  }

  public var screenshots: [Proto_Screenshot] {
    get {return _storage._screenshots}
    set {_uniqueStorage()._screenshots = newValue}
  }

  public var similarGames: [Proto_Game] {
    get {return _storage._similarGames}
    set {_uniqueStorage()._similarGames = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var standaloneExpansions: [Proto_Game] {
    get {return _storage._standaloneExpansions}
    set {_uniqueStorage()._standaloneExpansions = newValue}
  }

  public var status: Proto_GameStatusEnum {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var storyline: String {
    get {return _storage._storyline}
    set {_uniqueStorage()._storyline = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var tags: [Int32] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var themes: [Proto_Theme] {
    get {return _storage._themes}
    set {_uniqueStorage()._themes = newValue}
  }

  public var totalRating: Double {
    get {return _storage._totalRating}
    set {_uniqueStorage()._totalRating = newValue}
  }

  public var totalRatingCount: Int32 {
    get {return _storage._totalRatingCount}
    set {_uniqueStorage()._totalRatingCount = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var versionParent: Proto_Game {
    get {return _storage._versionParent ?? Proto_Game()}
    set {_uniqueStorage()._versionParent = newValue}
  }
  /// Returns true if `versionParent` has been explicitly set.
  public var hasVersionParent: Bool {return _storage._versionParent != nil}
  /// Clears the value of `versionParent`. Subsequent reads from it will return its default value.
  public mutating func clearVersionParent() {_uniqueStorage()._versionParent = nil}

  public var versionTitle: String {
    get {return _storage._versionTitle}
    set {_uniqueStorage()._versionTitle = newValue}
  }

  public var videos: [Proto_GameVideo] {
    get {return _storage._videos}
    set {_uniqueStorage()._videos = newValue}
  }

  public var websites: [Proto_Website] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var remakes: [Proto_Game] {
    get {return _storage._remakes}
    set {_uniqueStorage()._remakes = newValue}
  }

  public var remasters: [Proto_Game] {
    get {return _storage._remasters}
    set {_uniqueStorage()._remasters = newValue}
  }

  public var expandedGames: [Proto_Game] {
    get {return _storage._expandedGames}
    set {_uniqueStorage()._expandedGames = newValue}
  }

  public var ports: [Proto_Game] {
    get {return _storage._ports}
    set {_uniqueStorage()._ports = newValue}
  }

  public var forks: [Proto_Game] {
    get {return _storage._forks}
    set {_uniqueStorage()._forks = newValue}
  }

  public var languageSupports: [Proto_LanguageSupport] {
    get {return _storage._languageSupports}
    set {_uniqueStorage()._languageSupports = newValue}
  }

  public var gameLocalizations: [Proto_GameLocalization] {
    get {return _storage._gameLocalizations}
    set {_uniqueStorage()._gameLocalizations = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_GameEngineResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameengines: [Proto_GameEngine] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameEngine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var companies: [Proto_Company] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var logo: Proto_GameEngineLogo {
    get {return _storage._logo ?? Proto_GameEngineLogo()}
    set {_uniqueStorage()._logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return _storage._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {_uniqueStorage()._logo = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platforms: [Proto_Platform] {
    get {return _storage._platforms}
    set {_uniqueStorage()._platforms = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_GameEngineLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameenginelogos: [Proto_GameEngineLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameEngineLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameLocalizationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gamelocalizations: [Proto_GameLocalization] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameLocalization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var cover: Proto_Cover {
    get {return _storage._cover ?? Proto_Cover()}
    set {_uniqueStorage()._cover = newValue}
  }
  /// Returns true if `cover` has been explicitly set.
  public var hasCover: Bool {return _storage._cover != nil}
  /// Clears the value of `cover`. Subsequent reads from it will return its default value.
  public mutating func clearCover() {_uniqueStorage()._cover = nil}

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var region: Proto_Region {
    get {return _storage._region ?? Proto_Region()}
    set {_uniqueStorage()._region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return _storage._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {_uniqueStorage()._region = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_GameModeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gamemodes: [Proto_GameMode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameVersionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversions: [Proto_GameVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var features: [Proto_GameVersionFeature] = []

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var games: [Proto_Game] = []

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameVersionFeatureResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversionfeatures: [Proto_GameVersionFeature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_GameVersionFeatureCategoryEnum = .boolean

  public var description_p: String = String()

  public var position: Int32 = 0

  public var title: String = String()

  public var values: [Proto_GameVersionFeatureValue] = []

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeatureValueResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversionfeaturevalues: [Proto_GameVersionFeatureValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeatureValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var gameFeature: Proto_GameVersionFeature {
    get {return _gameFeature ?? Proto_GameVersionFeature()}
    set {_gameFeature = newValue}
  }
  /// Returns true if `gameFeature` has been explicitly set.
  public var hasGameFeature: Bool {return self._gameFeature != nil}
  /// Clears the value of `gameFeature`. Subsequent reads from it will return its default value.
  public mutating func clearGameFeature() {self._gameFeature = nil}

  public var includedFeature: Proto_GameVersionFeatureValueIncludedFeatureEnum = .notIncluded

  public var note: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
  fileprivate var _gameFeature: Proto_GameVersionFeature? = nil
}

public struct Proto_GameVideoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gamevideos: [Proto_GameVideo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVideo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var videoID: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_GenreResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genres: [Proto_Genre] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Genre {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_InvolvedCompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var involvedcompanies: [Proto_InvolvedCompany] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_InvolvedCompany {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var company: Proto_Company {
    get {return _company ?? Proto_Company()}
    set {_company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return self._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {self._company = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var developer: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var porting: Bool = false

  public var publisher: Bool = false

  public var supporting: Bool = false

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _company: Proto_Company? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_KeywordResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keywords: [Proto_Keyword] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Keyword {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_LanguageResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var languages: [Proto_Language] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Language {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var nativeName: String = String()

  public var locale: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_LanguageSupportResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var languagesupports: [Proto_LanguageSupport] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_LanguageSupport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var language: Proto_Language {
    get {return _storage._language ?? Proto_Language()}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  public var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  public mutating func clearLanguage() {_uniqueStorage()._language = nil}

  public var languageSupportType: Proto_LanguageSupportType {
    get {return _storage._languageSupportType ?? Proto_LanguageSupportType()}
    set {_uniqueStorage()._languageSupportType = newValue}
  }
  /// Returns true if `languageSupportType` has been explicitly set.
  public var hasLanguageSupportType: Bool {return _storage._languageSupportType != nil}
  /// Clears the value of `languageSupportType`. Subsequent reads from it will return its default value.
  public mutating func clearLanguageSupportType() {_uniqueStorage()._languageSupportType = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_LanguageSupportTypeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var languagesupporttypes: [Proto_LanguageSupportType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_LanguageSupportType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_MultiplayerModeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multiplayermodes: [Proto_MultiplayerMode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiplayerMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var campaigncoop: Bool = false

  public var dropin: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var lancoop: Bool = false

  public var offlinecoop: Bool = false

  public var offlinecoopmax: Int32 = 0

  public var offlinemax: Int32 = 0

  public var onlinecoop: Bool = false

  public var onlinecoopmax: Int32 = 0

  public var onlinemax: Int32 = 0

  public var platform: Proto_Platform {
    get {return _platform ?? Proto_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var splitscreen: Bool = false

  public var splitscreenonline: Bool = false

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
  fileprivate var _platform: Proto_Platform? = nil
}

public struct Proto_PlatformResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platforms: [Proto_Platform] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Platform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var abbreviation: String {
    get {return _storage._abbreviation}
    set {_uniqueStorage()._abbreviation = newValue}
  }

  public var alternativeName: String {
    get {return _storage._alternativeName}
    set {_uniqueStorage()._alternativeName = newValue}
  }

  public var category: Proto_PlatformCategoryEnum {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var generation: Int32 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platformLogo: Proto_PlatformLogo {
    get {return _storage._platformLogo ?? Proto_PlatformLogo()}
    set {_uniqueStorage()._platformLogo = newValue}
  }
  /// Returns true if `platformLogo` has been explicitly set.
  public var hasPlatformLogo: Bool {return _storage._platformLogo != nil}
  /// Clears the value of `platformLogo`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformLogo() {_uniqueStorage()._platformLogo = nil}

  public var platformFamily: Proto_PlatformFamily {
    get {return _storage._platformFamily ?? Proto_PlatformFamily()}
    set {_uniqueStorage()._platformFamily = newValue}
  }
  /// Returns true if `platformFamily` has been explicitly set.
  public var hasPlatformFamily: Bool {return _storage._platformFamily != nil}
  /// Clears the value of `platformFamily`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformFamily() {_uniqueStorage()._platformFamily = nil}

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var versions: [Proto_PlatformVersion] {
    get {return _storage._versions}
    set {_uniqueStorage()._versions = newValue}
  }

  public var websites: [Proto_PlatformWebsite] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_PlatformFamilyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformfamilies: [Proto_PlatformFamily] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformFamily {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var slug: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformlogos: [Proto_PlatformLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversions: [Proto_PlatformVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var companies: [Proto_PlatformVersionCompany] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  public var connectivity: String {
    get {return _storage._connectivity}
    set {_uniqueStorage()._connectivity = newValue}
  }

  public var cpu: String {
    get {return _storage._cpu}
    set {_uniqueStorage()._cpu = newValue}
  }

  public var graphics: String {
    get {return _storage._graphics}
    set {_uniqueStorage()._graphics = newValue}
  }

  public var mainManufacturer: Proto_PlatformVersionCompany {
    get {return _storage._mainManufacturer ?? Proto_PlatformVersionCompany()}
    set {_uniqueStorage()._mainManufacturer = newValue}
  }
  /// Returns true if `mainManufacturer` has been explicitly set.
  public var hasMainManufacturer: Bool {return _storage._mainManufacturer != nil}
  /// Clears the value of `mainManufacturer`. Subsequent reads from it will return its default value.
  public mutating func clearMainManufacturer() {_uniqueStorage()._mainManufacturer = nil}

  public var media: String {
    get {return _storage._media}
    set {_uniqueStorage()._media = newValue}
  }

  public var memory: String {
    get {return _storage._memory}
    set {_uniqueStorage()._memory = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var online: String {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  public var os: String {
    get {return _storage._os}
    set {_uniqueStorage()._os = newValue}
  }

  public var output: String {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  public var platformLogo: Proto_PlatformLogo {
    get {return _storage._platformLogo ?? Proto_PlatformLogo()}
    set {_uniqueStorage()._platformLogo = newValue}
  }
  /// Returns true if `platformLogo` has been explicitly set.
  public var hasPlatformLogo: Bool {return _storage._platformLogo != nil}
  /// Clears the value of `platformLogo`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformLogo() {_uniqueStorage()._platformLogo = nil}

  public var platformVersionReleaseDates: [Proto_PlatformVersionReleaseDate] {
    get {return _storage._platformVersionReleaseDates}
    set {_uniqueStorage()._platformVersionReleaseDates = newValue}
  }

  public var resolutions: String {
    get {return _storage._resolutions}
    set {_uniqueStorage()._resolutions = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var sound: String {
    get {return _storage._sound}
    set {_uniqueStorage()._sound = newValue}
  }

  public var storage: String {
    get {return _storage._storage}
    set {_uniqueStorage()._storage = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_PlatformVersionCompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversioncompanies: [Proto_PlatformVersionCompany] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionCompany {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var comment: String = String()

  public var company: Proto_Company {
    get {return _company ?? Proto_Company()}
    set {_company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return self._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {self._company = nil}

  public var developer: Bool = false

  public var manufacturer: Bool = false

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _company: Proto_Company? = nil
}

public struct Proto_PlatformVersionReleaseDateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversionreleasedates: [Proto_PlatformVersionReleaseDate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionReleaseDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var human: String = String()

  public var m: Int32 = 0

  public var platformVersion: Proto_PlatformVersion {
    get {return _platformVersion ?? Proto_PlatformVersion()}
    set {_platformVersion = newValue}
  }
  /// Returns true if `platformVersion` has been explicitly set.
  public var hasPlatformVersion: Bool {return self._platformVersion != nil}
  /// Clears the value of `platformVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformVersion() {self._platformVersion = nil}

  public var region: Proto_RegionRegionEnum = .regionRegionNull

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var y: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _platformVersion: Proto_PlatformVersion? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_PlatformWebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformwebsites: [Proto_PlatformWebsite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformWebsite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlayerPerspectiveResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var playerperspectives: [Proto_PlayerPerspective] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlayerPerspective {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_RegionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var regions: [Proto_Region] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Region {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var category: String = String()

  public var identifier: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_ReleaseDateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var releasedates: [Proto_ReleaseDate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ReleaseDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var category: Proto_DateFormatChangeDateCategoryEnum {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var human: String {
    get {return _storage._human}
    set {_uniqueStorage()._human = newValue}
  }

  public var m: Int32 {
    get {return _storage._m}
    set {_uniqueStorage()._m = newValue}
  }

  public var platform: Proto_Platform {
    get {return _storage._platform ?? Proto_Platform()}
    set {_uniqueStorage()._platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return _storage._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {_uniqueStorage()._platform = nil}

  public var region: Proto_RegionRegionEnum {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var y: Int32 {
    get {return _storage._y}
    set {_uniqueStorage()._y = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var status: Proto_ReleaseDateStatus {
    get {return _storage._status ?? Proto_ReleaseDateStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_ReleaseDateStatusResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var releasedatestatuses: [Proto_ReleaseDateStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ReleaseDateStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var description_p: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_ScreenshotResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var screenshots: [Proto_Screenshot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Screenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_SearchResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var searches: [Proto_Search] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Search {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var alternativeName: String {
    get {return _storage._alternativeName}
    set {_uniqueStorage()._alternativeName = newValue}
  }

  public var character: Proto_Character {
    get {return _storage._character ?? Proto_Character()}
    set {_uniqueStorage()._character = newValue}
  }
  /// Returns true if `character` has been explicitly set.
  public var hasCharacter: Bool {return _storage._character != nil}
  /// Clears the value of `character`. Subsequent reads from it will return its default value.
  public mutating func clearCharacter() {_uniqueStorage()._character = nil}

  public var collection: Proto_Collection {
    get {return _storage._collection ?? Proto_Collection()}
    set {_uniqueStorage()._collection = newValue}
  }
  /// Returns true if `collection` has been explicitly set.
  public var hasCollection: Bool {return _storage._collection != nil}
  /// Clears the value of `collection`. Subsequent reads from it will return its default value.
  public mutating func clearCollection() {_uniqueStorage()._collection = nil}

  public var company: Proto_Company {
    get {return _storage._company ?? Proto_Company()}
    set {_uniqueStorage()._company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return _storage._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {_uniqueStorage()._company = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platform: Proto_Platform {
    get {return _storage._platform ?? Proto_Platform()}
    set {_uniqueStorage()._platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return _storage._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {_uniqueStorage()._platform = nil}

  public var publishedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._publishedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._publishedAt = newValue}
  }
  /// Returns true if `publishedAt` has been explicitly set.
  public var hasPublishedAt: Bool {return _storage._publishedAt != nil}
  /// Clears the value of `publishedAt`. Subsequent reads from it will return its default value.
  public mutating func clearPublishedAt() {_uniqueStorage()._publishedAt = nil}

  public var testDummy: Proto_TestDummy {
    get {return _storage._testDummy ?? Proto_TestDummy()}
    set {_uniqueStorage()._testDummy = newValue}
  }
  /// Returns true if `testDummy` has been explicitly set.
  public var hasTestDummy: Bool {return _storage._testDummy != nil}
  /// Clears the value of `testDummy`. Subsequent reads from it will return its default value.
  public mutating func clearTestDummy() {_uniqueStorage()._testDummy = nil}

  public var theme: Proto_Theme {
    get {return _storage._theme ?? Proto_Theme()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  public var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  public mutating func clearTheme() {_uniqueStorage()._theme = nil}

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_TestDummyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var testdummies: [Proto_TestDummy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_TestDummy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var boolValue: Bool {
    get {return _storage._boolValue}
    set {_uniqueStorage()._boolValue = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var enumTest: Proto_TestDummyEnumTestEnum {
    get {return _storage._enumTest}
    set {_uniqueStorage()._enumTest = newValue}
  }

  public var floatValue: Double {
    get {return _storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var integerArray: [Int32] {
    get {return _storage._integerArray}
    set {_uniqueStorage()._integerArray = newValue}
  }

  public var integerValue: Int32 {
    get {return _storage._integerValue}
    set {_uniqueStorage()._integerValue = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var newIntegerValue: Int32 {
    get {return _storage._newIntegerValue}
    set {_uniqueStorage()._newIntegerValue = newValue}
  }

  public var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var stringArray: [String] {
    get {return _storage._stringArray}
    set {_uniqueStorage()._stringArray = newValue}
  }

  public var testDummies: [Proto_TestDummy] {
    get {return _storage._testDummies}
    set {_uniqueStorage()._testDummies = newValue}
  }

  public var testDummy: Proto_TestDummy {
    get {return _storage._testDummy ?? Proto_TestDummy()}
    set {_uniqueStorage()._testDummy = newValue}
  }
  /// Returns true if `testDummy` has been explicitly set.
  public var hasTestDummy: Bool {return _storage._testDummy != nil}
  /// Clears the value of `testDummy`. Subsequent reads from it will return its default value.
  public mutating func clearTestDummy() {_uniqueStorage()._testDummy = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_ThemeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var themes: [Proto_Theme] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Theme {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_WebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var websites: [Proto_Website] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Website {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_AgeRatingCategoryEnum: @unchecked Sendable {}
extension Proto_AgeRatingRatingEnum: @unchecked Sendable {}
extension Proto_AgeRatingContentDescriptionCategoryEnum: @unchecked Sendable {}
extension Proto_GenderGenderEnum: @unchecked Sendable {}
extension Proto_CharacterSpeciesEnum: @unchecked Sendable {}
extension Proto_DateFormatChangeDateCategoryEnum: @unchecked Sendable {}
extension Proto_WebsiteCategoryEnum: @unchecked Sendable {}
extension Proto_ExternalGameCategoryEnum: @unchecked Sendable {}
extension Proto_ExternalGameMediaEnum: @unchecked Sendable {}
extension Proto_GameCategoryEnum: @unchecked Sendable {}
extension Proto_GameStatusEnum: @unchecked Sendable {}
extension Proto_GameVersionFeatureCategoryEnum: @unchecked Sendable {}
extension Proto_GameVersionFeatureValueIncludedFeatureEnum: @unchecked Sendable {}
extension Proto_PlatformCategoryEnum: @unchecked Sendable {}
extension Proto_RegionRegionEnum: @unchecked Sendable {}
extension Proto_TestDummyEnumTestEnum: @unchecked Sendable {}
extension Proto_Count: @unchecked Sendable {}
extension Proto_MultiQueryResult: @unchecked Sendable {}
extension Proto_MultiQueryResultArray: @unchecked Sendable {}
extension Proto_AgeRatingResult: @unchecked Sendable {}
extension Proto_AgeRating: @unchecked Sendable {}
extension Proto_AgeRatingContentDescriptionResult: @unchecked Sendable {}
extension Proto_AgeRatingContentDescription: @unchecked Sendable {}
extension Proto_AlternativeNameResult: @unchecked Sendable {}
extension Proto_AlternativeName: @unchecked Sendable {}
extension Proto_ArtworkResult: @unchecked Sendable {}
extension Proto_Artwork: @unchecked Sendable {}
extension Proto_CharacterResult: @unchecked Sendable {}
extension Proto_Character: @unchecked Sendable {}
extension Proto_CharacterMugShotResult: @unchecked Sendable {}
extension Proto_CharacterMugShot: @unchecked Sendable {}
extension Proto_CollectionResult: @unchecked Sendable {}
extension Proto_Collection: @unchecked Sendable {}
extension Proto_CompanyResult: @unchecked Sendable {}
extension Proto_Company: @unchecked Sendable {}
extension Proto_CompanyLogoResult: @unchecked Sendable {}
extension Proto_CompanyLogo: @unchecked Sendable {}
extension Proto_CompanyWebsiteResult: @unchecked Sendable {}
extension Proto_CompanyWebsite: @unchecked Sendable {}
extension Proto_CoverResult: @unchecked Sendable {}
extension Proto_Cover: @unchecked Sendable {}
extension Proto_ExternalGameResult: @unchecked Sendable {}
extension Proto_ExternalGame: @unchecked Sendable {}
extension Proto_FranchiseResult: @unchecked Sendable {}
extension Proto_Franchise: @unchecked Sendable {}
extension Proto_GameResult: @unchecked Sendable {}
extension Proto_Game: @unchecked Sendable {}
extension Proto_GameEngineResult: @unchecked Sendable {}
extension Proto_GameEngine: @unchecked Sendable {}
extension Proto_GameEngineLogoResult: @unchecked Sendable {}
extension Proto_GameEngineLogo: @unchecked Sendable {}
extension Proto_GameLocalizationResult: @unchecked Sendable {}
extension Proto_GameLocalization: @unchecked Sendable {}
extension Proto_GameModeResult: @unchecked Sendable {}
extension Proto_GameMode: @unchecked Sendable {}
extension Proto_GameVersionResult: @unchecked Sendable {}
extension Proto_GameVersion: @unchecked Sendable {}
extension Proto_GameVersionFeatureResult: @unchecked Sendable {}
extension Proto_GameVersionFeature: @unchecked Sendable {}
extension Proto_GameVersionFeatureValueResult: @unchecked Sendable {}
extension Proto_GameVersionFeatureValue: @unchecked Sendable {}
extension Proto_GameVideoResult: @unchecked Sendable {}
extension Proto_GameVideo: @unchecked Sendable {}
extension Proto_GenreResult: @unchecked Sendable {}
extension Proto_Genre: @unchecked Sendable {}
extension Proto_InvolvedCompanyResult: @unchecked Sendable {}
extension Proto_InvolvedCompany: @unchecked Sendable {}
extension Proto_KeywordResult: @unchecked Sendable {}
extension Proto_Keyword: @unchecked Sendable {}
extension Proto_LanguageResult: @unchecked Sendable {}
extension Proto_Language: @unchecked Sendable {}
extension Proto_LanguageSupportResult: @unchecked Sendable {}
extension Proto_LanguageSupport: @unchecked Sendable {}
extension Proto_LanguageSupportTypeResult: @unchecked Sendable {}
extension Proto_LanguageSupportType: @unchecked Sendable {}
extension Proto_MultiplayerModeResult: @unchecked Sendable {}
extension Proto_MultiplayerMode: @unchecked Sendable {}
extension Proto_PlatformResult: @unchecked Sendable {}
extension Proto_Platform: @unchecked Sendable {}
extension Proto_PlatformFamilyResult: @unchecked Sendable {}
extension Proto_PlatformFamily: @unchecked Sendable {}
extension Proto_PlatformLogoResult: @unchecked Sendable {}
extension Proto_PlatformLogo: @unchecked Sendable {}
extension Proto_PlatformVersionResult: @unchecked Sendable {}
extension Proto_PlatformVersion: @unchecked Sendable {}
extension Proto_PlatformVersionCompanyResult: @unchecked Sendable {}
extension Proto_PlatformVersionCompany: @unchecked Sendable {}
extension Proto_PlatformVersionReleaseDateResult: @unchecked Sendable {}
extension Proto_PlatformVersionReleaseDate: @unchecked Sendable {}
extension Proto_PlatformWebsiteResult: @unchecked Sendable {}
extension Proto_PlatformWebsite: @unchecked Sendable {}
extension Proto_PlayerPerspectiveResult: @unchecked Sendable {}
extension Proto_PlayerPerspective: @unchecked Sendable {}
extension Proto_RegionResult: @unchecked Sendable {}
extension Proto_Region: @unchecked Sendable {}
extension Proto_ReleaseDateResult: @unchecked Sendable {}
extension Proto_ReleaseDate: @unchecked Sendable {}
extension Proto_ReleaseDateStatusResult: @unchecked Sendable {}
extension Proto_ReleaseDateStatus: @unchecked Sendable {}
extension Proto_ScreenshotResult: @unchecked Sendable {}
extension Proto_Screenshot: @unchecked Sendable {}
extension Proto_SearchResult: @unchecked Sendable {}
extension Proto_Search: @unchecked Sendable {}
extension Proto_TestDummyResult: @unchecked Sendable {}
extension Proto_TestDummy: @unchecked Sendable {}
extension Proto_ThemeResult: @unchecked Sendable {}
extension Proto_Theme: @unchecked Sendable {}
extension Proto_WebsiteResult: @unchecked Sendable {}
extension Proto_Website: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_AgeRatingCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGERATING_CATEGORY_NULL"),
    1: .same(proto: "ESRB"),
    2: .same(proto: "PEGI"),
    3: .same(proto: "CERO"),
    4: .same(proto: "USK"),
    5: .same(proto: "GRAC"),
    6: .same(proto: "CLASS_IND"),
    7: .same(proto: "ACB"),
  ]
}

extension Proto_AgeRatingRatingEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGERATING_RATING_NULL"),
    1: .same(proto: "THREE"),
    2: .same(proto: "SEVEN"),
    3: .same(proto: "TWELVE"),
    4: .same(proto: "SIXTEEN"),
    5: .same(proto: "EIGHTEEN"),
    6: .same(proto: "RP"),
    7: .same(proto: "EC"),
    8: .same(proto: "E"),
    9: .same(proto: "E10"),
    10: .same(proto: "T"),
    11: .same(proto: "M"),
    12: .same(proto: "AO"),
    13: .same(proto: "CERO_A"),
    14: .same(proto: "CERO_B"),
    15: .same(proto: "CERO_C"),
    16: .same(proto: "CERO_D"),
    17: .same(proto: "CERO_Z"),
    18: .same(proto: "USK_0"),
    19: .same(proto: "USK_6"),
    20: .same(proto: "USK_12"),
    21: .same(proto: "USK_16"),
    22: .same(proto: "USK_18"),
    23: .same(proto: "GRAC_ALL"),
    24: .same(proto: "GRAC_TWELVE"),
    25: .same(proto: "GRAC_FIFTEEN"),
    26: .same(proto: "GRAC_EIGHTEEN"),
    27: .same(proto: "GRAC_TESTING"),
    28: .same(proto: "CLASS_IND_L"),
    29: .same(proto: "CLASS_IND_TEN"),
    30: .same(proto: "CLASS_IND_TWELVE"),
    31: .same(proto: "CLASS_IND_FOURTEEN"),
    32: .same(proto: "CLASS_IND_SIXTEEN"),
    33: .same(proto: "CLASS_IND_EIGHTEEN"),
    34: .same(proto: "ACB_G"),
    35: .same(proto: "ACB_PG"),
    36: .same(proto: "ACB_M"),
    37: .same(proto: "ACB_MA15"),
    38: .same(proto: "ACB_R18"),
    39: .same(proto: "ACB_RC"),
  ]
}

extension Proto_AgeRatingContentDescriptionCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL"),
    1: .same(proto: "ESRB_ALCOHOL_REFERENCE"),
    2: .same(proto: "ESRB_ANIMATED_BLOOD"),
    3: .same(proto: "ESRB_BLOOD"),
    4: .same(proto: "ESRB_BLOOD_AND_GORE"),
    5: .same(proto: "ESRB_CARTOON_VIOLENCE"),
    6: .same(proto: "ESRB_COMIC_MISCHIEF"),
    7: .same(proto: "ESRB_CRUDE_HUMOR"),
    8: .same(proto: "ESRB_DRUG_REFERENCE"),
    9: .same(proto: "ESRB_FANTASY_VIOLENCE"),
    10: .same(proto: "ESRB_INTENSE_VIOLENCE"),
    11: .same(proto: "ESRB_LANGUAGE"),
    12: .same(proto: "ESRB_LYRICS"),
    13: .same(proto: "ESRB_MATURE_HUMOR"),
    14: .same(proto: "ESRB_NUDITY"),
    15: .same(proto: "ESRB_PARTIAL_NUDITY"),
    16: .same(proto: "ESRB_REAL_GAMBLING"),
    17: .same(proto: "ESRB_SEXUAL_CONTENT"),
    18: .same(proto: "ESRB_SEXUAL_THEMES"),
    19: .same(proto: "ESRB_SEXUAL_VIOLENCE"),
    20: .same(proto: "ESRB_SIMULATED_GAMBLING"),
    21: .same(proto: "ESRB_STRONG_LANGUAGE"),
    22: .same(proto: "ESRB_STRONG_LYRICS"),
    23: .same(proto: "ESRB_STRONG_SEXUAL_CONTENT"),
    24: .same(proto: "ESRB_SUGGESTIVE_THEMES"),
    25: .same(proto: "ESRB_TOBACCO_REFERENCE"),
    26: .same(proto: "ESRB_USE_OF_ALCOHOL"),
    27: .same(proto: "ESRB_USE_OF_DRUGS"),
    28: .same(proto: "ESRB_USE_OF_TOBACCO"),
    29: .same(proto: "ESRB_VIOLENCE"),
    30: .same(proto: "ESRB_VIOLENT_REFERENCES"),
    31: .same(proto: "ESRB_ANIMATED_VIOLENCE"),
    32: .same(proto: "ESRB_MILD_LANGUAGE"),
    33: .same(proto: "ESRB_MILD_VIOLENCE"),
    34: .same(proto: "ESRB_USE_OF_DRUGS_AND_ALCOHOL"),
    35: .same(proto: "ESRB_DRUG_AND_ALCOHOL_REFERENCE"),
    36: .same(proto: "ESRB_MILD_SUGGESTIVE_THEMES"),
    37: .same(proto: "ESRB_MILD_CARTOON_VIOLENCE"),
    38: .same(proto: "ESRB_MILD_BLOOD"),
    39: .same(proto: "ESRB_REALISTIC_BLOOD_AND_GORE"),
    40: .same(proto: "ESRB_REALISTIC_VIOLENCE"),
    41: .same(proto: "ESRB_ALCOHOL_AND_TOBACCO_REFERENCE"),
    42: .same(proto: "ESRB_MATURE_SEXUAL_THEMES"),
    43: .same(proto: "ESRB_MILD_ANIMATED_VIOLENCE"),
    44: .same(proto: "ESRB_MILD_SEXUAL_THEMES"),
    45: .same(proto: "ESRB_USE_OF_ALCOHOL_AND_TOBACCO"),
    46: .same(proto: "ESRB_ANIMATED_BLOOD_AND_GORE"),
    47: .same(proto: "ESRB_MILD_FANTASY_VIOLENCE"),
    48: .same(proto: "ESRB_MILD_LYRICS"),
    49: .same(proto: "ESRB_REALISTIC_BLOOD"),
    50: .same(proto: "PEGI_VIOLENCE"),
    51: .same(proto: "PEGI_SEX"),
    52: .same(proto: "PEGI_DRUGS"),
    53: .same(proto: "PEGI_FEAR"),
    54: .same(proto: "PEGI_DISCRIMINATION"),
    55: .same(proto: "PEGI_BAD_LANGUAGE"),
    56: .same(proto: "PEGI_GAMBLING"),
    57: .same(proto: "PEGI_ONLINE_GAMEPLAY"),
    58: .same(proto: "PEGI_IN_GAME_PURCHASES"),
    59: .same(proto: "CERO_LOVE"),
    60: .same(proto: "CERO_SEXUAL_CONTENT"),
    61: .same(proto: "CERO_VIOLENCE"),
    62: .same(proto: "CERO_HORROR"),
    63: .same(proto: "CERO_DRINKING_SMOKING"),
    64: .same(proto: "CERO_GAMBLING"),
    65: .same(proto: "CERO_CRIME"),
    66: .same(proto: "CERO_CONTROLLED_SUBSTANCES"),
    67: .same(proto: "CERO_LANGUAGES_AND_OTHERS"),
    68: .same(proto: "GRAC_SEXUALITY"),
    69: .same(proto: "GRAC_VIOLENCE"),
    70: .same(proto: "GRAC_FEAR_HORROR_THREATENING"),
    71: .same(proto: "GRAC_LANGUAGE"),
    72: .same(proto: "GRAC_ALCOHOL_TOBACCO_DRUG"),
    73: .same(proto: "GRAC_CRIME_ANTI_SOCIAL"),
    74: .same(proto: "GRAC_GAMBLING"),
    75: .same(proto: "CLASS_IND_VIOLENCIA"),
    76: .same(proto: "CLASS_IND_VIOLENCIA_EXTREMA"),
    77: .same(proto: "CLASS_IND_CONTEUDO_SEXUAL"),
    78: .same(proto: "CLASS_IND_NUDEZ"),
    79: .same(proto: "CLASS_IND_SEXO"),
    80: .same(proto: "CLASS_IND_SEXO_EXPLICITO"),
    81: .same(proto: "CLASS_IND_DROGAS"),
    82: .same(proto: "CLASS_IND_DROGAS_LICITAS"),
    83: .same(proto: "CLASS_IND_DROGAS_ILICITAS"),
    84: .same(proto: "CLASS_IND_LINGUAGEM_IMPROPRIA"),
    85: .same(proto: "CLASS_IND_ATOS_CRIMINOSOS"),
  ]
}

extension Proto_GenderGenderEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MALE"),
    1: .same(proto: "FEMALE"),
    2: .same(proto: "OTHER"),
  ]
}

extension Proto_CharacterSpeciesEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHARACTER_SPECIES_NULL"),
    1: .same(proto: "HUMAN"),
    2: .same(proto: "ALIEN"),
    3: .same(proto: "ANIMAL"),
    4: .same(proto: "ANDROID"),
    5: .same(proto: "UNKNOWN"),
  ]
}

extension Proto_DateFormatChangeDateCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YYYYMMMMDD"),
    1: .same(proto: "YYYYMMMM"),
    2: .same(proto: "YYYY"),
    3: .same(proto: "YYYYQ1"),
    4: .same(proto: "YYYYQ2"),
    5: .same(proto: "YYYYQ3"),
    6: .same(proto: "YYYYQ4"),
    7: .same(proto: "TBD"),
  ]
}

extension Proto_WebsiteCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WEBSITE_CATEGORY_NULL"),
    1: .same(proto: "WEBSITE_OFFICIAL"),
    2: .same(proto: "WEBSITE_WIKIA"),
    3: .same(proto: "WEBSITE_WIKIPEDIA"),
    4: .same(proto: "WEBSITE_FACEBOOK"),
    5: .same(proto: "WEBSITE_TWITTER"),
    6: .same(proto: "WEBSITE_TWITCH"),
    8: .same(proto: "WEBSITE_INSTAGRAM"),
    9: .same(proto: "WEBSITE_YOUTUBE"),
    10: .same(proto: "WEBSITE_IPHONE"),
    11: .same(proto: "WEBSITE_IPAD"),
    12: .same(proto: "WEBSITE_ANDROID"),
    13: .same(proto: "WEBSITE_STEAM"),
    14: .same(proto: "WEBSITE_REDDIT"),
    15: .same(proto: "WEBSITE_ITCH"),
    16: .same(proto: "WEBSITE_EPICGAMES"),
    17: .same(proto: "WEBSITE_GOG"),
    18: .same(proto: "WEBSITE_DISCORD"),
  ]
}

extension Proto_ExternalGameCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNALGAME_CATEGORY_NULL"),
    1: .same(proto: "EXTERNALGAME_STEAM"),
    5: .same(proto: "EXTERNALGAME_GOG"),
    10: .same(proto: "EXTERNALGAME_YOUTUBE"),
    11: .same(proto: "EXTERNALGAME_MICROSOFT"),
    13: .same(proto: "EXTERNALGAME_APPLE"),
    14: .same(proto: "EXTERNALGAME_TWITCH"),
    15: .same(proto: "EXTERNALGAME_ANDROID"),
    20: .same(proto: "EXTERNALGAME_AMAZON_ASIN"),
    22: .same(proto: "EXTERNALGAME_AMAZON_LUNA"),
    23: .same(proto: "EXTERNALGAME_AMAZON_ADG"),
    26: .same(proto: "EXTERNALGAME_EPIC_GAME_STORE"),
    28: .same(proto: "EXTERNALGAME_OCULUS"),
    29: .same(proto: "EXTERNALGAME_UTOMIK"),
    30: .same(proto: "EXTERNALGAME_ITCH_IO"),
    31: .same(proto: "EXTERNALGAME_XBOX_MARKETPLACE"),
    32: .same(proto: "EXTERNALGAME_KARTRIDGE"),
    36: .same(proto: "EXTERNALGAME_PLAYSTATION_STORE_US"),
    37: .same(proto: "EXTERNALGAME_FOCUS_ENTERTAINMENT"),
    54: .same(proto: "EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD"),
    55: .same(proto: "EXTERNALGAME_GAMEJOLT"),
  ]
}

extension Proto_ExternalGameMediaEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNALGAME_MEDIA_NULL"),
    1: .same(proto: "EXTERNALGAME_DIGITAL"),
    2: .same(proto: "EXTERNALGAME_PHYSICAL"),
  ]
}

extension Proto_GameCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAIN_GAME"),
    1: .same(proto: "DLC_ADDON"),
    2: .same(proto: "EXPANSION"),
    3: .same(proto: "BUNDLE"),
    4: .same(proto: "STANDALONE_EXPANSION"),
    5: .same(proto: "MOD"),
    6: .same(proto: "EPISODE"),
    7: .same(proto: "SEASON"),
    8: .same(proto: "REMAKE"),
    9: .same(proto: "REMASTER"),
    10: .same(proto: "EXPANDED_GAME"),
    11: .same(proto: "PORT"),
    12: .same(proto: "FORK"),
    13: .same(proto: "PACK"),
    14: .same(proto: "UPDATE"),
  ]
}

extension Proto_GameStatusEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RELEASED"),
    2: .same(proto: "ALPHA"),
    3: .same(proto: "BETA"),
    4: .same(proto: "EARLY_ACCESS"),
    5: .same(proto: "OFFLINE"),
    6: .same(proto: "CANCELLED"),
    7: .same(proto: "RUMORED"),
    8: .same(proto: "DELISTED"),
  ]
}

extension Proto_GameVersionFeatureCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOOLEAN"),
    1: .same(proto: "DESCRIPTION"),
  ]
}

extension Proto_GameVersionFeatureValueIncludedFeatureEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_INCLUDED"),
    1: .same(proto: "INCLUDED"),
    2: .same(proto: "PRE_ORDER_ONLY"),
  ]
}

extension Proto_PlatformCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_CATEGORY_NULL"),
    1: .same(proto: "CONSOLE"),
    2: .same(proto: "ARCADE"),
    3: .same(proto: "PLATFORM"),
    4: .same(proto: "OPERATING_SYSTEM"),
    5: .same(proto: "PORTABLE_CONSOLE"),
    6: .same(proto: "COMPUTER"),
  ]
}

extension Proto_RegionRegionEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGION_REGION_NULL"),
    1: .same(proto: "EUROPE"),
    2: .same(proto: "NORTH_AMERICA"),
    3: .same(proto: "AUSTRALIA"),
    4: .same(proto: "NEW_ZEALAND"),
    5: .same(proto: "JAPAN"),
    6: .same(proto: "CHINA"),
    7: .same(proto: "ASIA"),
    8: .same(proto: "WORLDWIDE"),
    9: .same(proto: "KOREA"),
    10: .same(proto: "BRAZIL"),
  ]
}

extension Proto_TestDummyEnumTestEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TESTDUMMY_ENUM_TEST_NULL"),
    1: .same(proto: "ENUM1"),
    2: .same(proto: "ENUM2"),
  ]
}

extension Proto_Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Count, rhs: Proto_Count) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiQueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiQueryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "results"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.results) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.results, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiQueryResult, rhs: Proto_MultiQueryResult) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.results != rhs.results {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiQueryResultArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiQueryResultArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiQueryResultArray, rhs: Proto_MultiQueryResultArray) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ageratings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ageratings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ageratings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ageratings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingResult, rhs: Proto_AgeRatingResult) -> Bool {
    if lhs.ageratings != rhs.ageratings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRating"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "content_descriptions"),
    4: .same(proto: "rating"),
    5: .standard(proto: "rating_cover_url"),
    6: .same(proto: "synopsis"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contentDescriptions) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rating) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ratingCoverURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.synopsis) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .ageratingCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.contentDescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contentDescriptions, fieldNumber: 3)
    }
    if self.rating != .ageratingRatingNull {
      try visitor.visitSingularEnumField(value: self.rating, fieldNumber: 4)
    }
    if !self.ratingCoverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.ratingCoverURL, fieldNumber: 5)
    }
    if !self.synopsis.isEmpty {
      try visitor.visitSingularStringField(value: self.synopsis, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRating, rhs: Proto_AgeRating) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.contentDescriptions != rhs.contentDescriptions {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.ratingCoverURL != rhs.ratingCoverURL {return false}
    if lhs.synopsis != rhs.synopsis {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingContentDescriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingContentDescriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ageratingcontentdescriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ageratingcontentdescriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ageratingcontentdescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ageratingcontentdescriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingContentDescriptionResult, rhs: Proto_AgeRatingContentDescriptionResult) -> Bool {
    if lhs.ageratingcontentdescriptions != rhs.ageratingcontentdescriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingContentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingContentDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "description"),
    4: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .ageratingcontentdescriptionCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingContentDescription, rhs: Proto_AgeRatingContentDescription) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AlternativeNameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlternativeNameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alternativenames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alternativenames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alternativenames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alternativenames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AlternativeNameResult, rhs: Proto_AlternativeNameResult) -> Bool {
    if lhs.alternativenames != rhs.alternativenames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AlternativeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlternativeName"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "comment"),
    3: .same(proto: "game"),
    4: .same(proto: "name"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AlternativeName, rhs: Proto_AlternativeName) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ArtworkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArtworkResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artworks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artworks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artworks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artworks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ArtworkResult, rhs: Proto_ArtworkResult) -> Bool {
    if lhs.artworks != rhs.artworks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Artwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Artwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 8)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Artwork, rhs: Proto_Artwork) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs._game != rhs._game {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.characters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.characters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterResult, rhs: Proto_CharacterResult) -> Bool {
    if lhs.characters != rhs.characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Character: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Character"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "akas"),
    3: .standard(proto: "country_name"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "description"),
    6: .same(proto: "games"),
    7: .same(proto: "gender"),
    8: .standard(proto: "mug_shot"),
    9: .same(proto: "name"),
    10: .same(proto: "slug"),
    11: .same(proto: "species"),
    12: .standard(proto: "updated_at"),
    13: .same(proto: "url"),
    14: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _akas: [String] = []
    var _countryName: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _games: [Proto_Game] = []
    var _gender: Proto_GenderGenderEnum = .male
    var _mugShot: Proto_CharacterMugShot? = nil
    var _name: String = String()
    var _slug: String = String()
    var _species: Proto_CharacterSpeciesEnum = .characterSpeciesNull
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _akas = source._akas
      _countryName = source._countryName
      _createdAt = source._createdAt
      _description_p = source._description_p
      _games = source._games
      _gender = source._gender
      _mugShot = source._mugShot
      _name = source._name
      _slug = source._slug
      _species = source._species
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._akas) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._countryName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._games) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._mugShot) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._species) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._akas.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._akas, fieldNumber: 2)
      }
      if !_storage._countryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryName, fieldNumber: 3)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._games.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._games, fieldNumber: 6)
      }
      if _storage._gender != .male {
        try visitor.visitSingularEnumField(value: _storage._gender, fieldNumber: 7)
      }
      try { if let v = _storage._mugShot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 10)
      }
      if _storage._species != .characterSpeciesNull {
        try visitor.visitSingularEnumField(value: _storage._species, fieldNumber: 11)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 13)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Character, rhs: Proto_Character) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._akas != rhs_storage._akas {return false}
        if _storage._countryName != rhs_storage._countryName {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._games != rhs_storage._games {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._mugShot != rhs_storage._mugShot {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._species != rhs_storage._species {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterMugShotResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterMugShotResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "charactermugshots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.charactermugshots) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.charactermugshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.charactermugshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterMugShotResult, rhs: Proto_CharacterMugShotResult) -> Bool {
    if lhs.charactermugshots != rhs.charactermugshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterMugShot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterMugShot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterMugShot, rhs: Proto_CharacterMugShot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CollectionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collections"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CollectionResult, rhs: Proto_CollectionResult) -> Bool {
    if lhs.collections != rhs.collections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "games"),
    4: .same(proto: "name"),
    5: .same(proto: "slug"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 5)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Collection, rhs: Proto_Collection) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.games != rhs.games {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyResult, rhs: Proto_CompanyResult) -> Bool {
    if lhs.companies != rhs.companies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Company: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Company"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "change_date"),
    3: .standard(proto: "change_date_category"),
    4: .standard(proto: "changed_company_id"),
    5: .same(proto: "country"),
    6: .standard(proto: "created_at"),
    7: .same(proto: "description"),
    8: .same(proto: "developed"),
    9: .same(proto: "logo"),
    10: .same(proto: "name"),
    11: .same(proto: "parent"),
    12: .same(proto: "published"),
    13: .same(proto: "slug"),
    14: .standard(proto: "start_date"),
    15: .standard(proto: "start_date_category"),
    16: .standard(proto: "updated_at"),
    17: .same(proto: "url"),
    18: .same(proto: "websites"),
    19: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _changeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _changeDateCategory: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd
    var _changedCompanyID: Proto_Company? = nil
    var _country: Int32 = 0
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _developed: [Proto_Game] = []
    var _logo: Proto_CompanyLogo? = nil
    var _name: String = String()
    var _parent: Proto_Company? = nil
    var _published: [Proto_Game] = []
    var _slug: String = String()
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startDateCategory: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _websites: [Proto_CompanyWebsite] = []
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _changeDate = source._changeDate
      _changeDateCategory = source._changeDateCategory
      _changedCompanyID = source._changedCompanyID
      _country = source._country
      _createdAt = source._createdAt
      _description_p = source._description_p
      _developed = source._developed
      _logo = source._logo
      _name = source._name
      _parent = source._parent
      _published = source._published
      _slug = source._slug
      _startDate = source._startDate
      _startDateCategory = source._startDateCategory
      _updatedAt = source._updatedAt
      _url = source._url
      _websites = source._websites
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._changeDate) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._changeDateCategory) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._changedCompanyID) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._country) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._developed) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._logo) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._published) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._startDateCategory) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._changeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._changeDateCategory != .yyyymmmmdd {
        try visitor.visitSingularEnumField(value: _storage._changeDateCategory, fieldNumber: 3)
      }
      try { if let v = _storage._changedCompanyID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._country != 0 {
        try visitor.visitSingularInt32Field(value: _storage._country, fieldNumber: 5)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if !_storage._developed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._developed, fieldNumber: 8)
      }
      try { if let v = _storage._logo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 10)
      }
      try { if let v = _storage._parent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._published.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._published, fieldNumber: 12)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 13)
      }
      try { if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._startDateCategory != .yyyymmmmdd {
        try visitor.visitSingularEnumField(value: _storage._startDateCategory, fieldNumber: 15)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 17)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 18)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Company, rhs: Proto_Company) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._changeDate != rhs_storage._changeDate {return false}
        if _storage._changeDateCategory != rhs_storage._changeDateCategory {return false}
        if _storage._changedCompanyID != rhs_storage._changedCompanyID {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._developed != rhs_storage._developed {return false}
        if _storage._logo != rhs_storage._logo {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._published != rhs_storage._published {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._startDateCategory != rhs_storage._startDateCategory {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companylogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companylogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companylogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companylogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyLogoResult, rhs: Proto_CompanyLogoResult) -> Bool {
    if lhs.companylogos != rhs.companylogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyLogo, rhs: Proto_CompanyLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyWebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyWebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companywebsites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companywebsites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companywebsites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companywebsites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyWebsiteResult, rhs: Proto_CompanyWebsiteResult) -> Bool {
    if lhs.companywebsites != rhs.companywebsites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyWebsite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyWebsite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "trusted"),
    4: .same(proto: "url"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyWebsite, rhs: Proto_CompanyWebsite) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CoverResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoverResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "covers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.covers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.covers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CoverResult, rhs: Proto_CoverResult) -> Bool {
    if lhs.covers != rhs.covers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Cover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cover"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
    10: .standard(proto: "game_localization"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _alphaChannel: Bool = false
    var _animated: Bool = false
    var _game: Proto_Game? = nil
    var _height: Int32 = 0
    var _imageID: String = String()
    var _url: String = String()
    var _width: Int32 = 0
    var _checksum: String = String()
    var _gameLocalization: Proto_GameLocalization? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _alphaChannel = source._alphaChannel
      _animated = source._animated
      _game = source._game
      _height = source._height
      _imageID = source._imageID
      _url = source._url
      _width = source._width
      _checksum = source._checksum
      _gameLocalization = source._gameLocalization
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._alphaChannel) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._animated) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._imageID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._width) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._gameLocalization) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._alphaChannel != false {
        try visitor.visitSingularBoolField(value: _storage._alphaChannel, fieldNumber: 2)
      }
      if _storage._animated != false {
        try visitor.visitSingularBoolField(value: _storage._animated, fieldNumber: 3)
      }
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 5)
      }
      if !_storage._imageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageID, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 8)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 9)
      }
      try { if let v = _storage._gameLocalization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Cover, rhs: Proto_Cover) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._alphaChannel != rhs_storage._alphaChannel {return false}
        if _storage._animated != rhs_storage._animated {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._imageID != rhs_storage._imageID {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        if _storage._gameLocalization != rhs_storage._gameLocalization {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExternalGameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalGameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "externalgames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.externalgames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalgames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalgames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ExternalGameResult, rhs: Proto_ExternalGameResult) -> Bool {
    if lhs.externalgames != rhs.externalgames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExternalGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "game"),
    5: .same(proto: "name"),
    6: .same(proto: "uid"),
    7: .standard(proto: "updated_at"),
    8: .same(proto: "url"),
    9: .same(proto: "year"),
    10: .same(proto: "media"),
    11: .same(proto: "platform"),
    12: .same(proto: "countries"),
    13: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.media) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.countries) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .externalgameCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 6)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 8)
    }
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 9)
    }
    if self.media != .externalgameMediaNull {
      try visitor.visitSingularEnumField(value: self.media, fieldNumber: 10)
    }
    try { if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.countries.isEmpty {
      try visitor.visitPackedInt32Field(value: self.countries, fieldNumber: 12)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ExternalGame, rhs: Proto_ExternalGame) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.year != rhs.year {return false}
    if lhs.media != rhs.media {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.countries != rhs.countries {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FranchiseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FranchiseResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "franchises"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.franchises) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.franchises.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.franchises, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FranchiseResult, rhs: Proto_FranchiseResult) -> Bool {
    if lhs.franchises != rhs.franchises {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Franchise: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Franchise"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "games"),
    4: .same(proto: "name"),
    5: .same(proto: "slug"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 5)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Franchise, rhs: Proto_Franchise) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.games != rhs.games {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "games"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameResult, rhs: Proto_GameResult) -> Bool {
    if lhs.games != rhs.games {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Game: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Game"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "age_ratings"),
    3: .standard(proto: "aggregated_rating"),
    4: .standard(proto: "aggregated_rating_count"),
    5: .standard(proto: "alternative_names"),
    6: .same(proto: "artworks"),
    7: .same(proto: "bundles"),
    8: .same(proto: "category"),
    9: .same(proto: "collection"),
    10: .same(proto: "cover"),
    11: .standard(proto: "created_at"),
    12: .same(proto: "dlcs"),
    13: .same(proto: "expansions"),
    14: .standard(proto: "external_games"),
    15: .standard(proto: "first_release_date"),
    16: .same(proto: "follows"),
    17: .same(proto: "franchise"),
    18: .same(proto: "franchises"),
    19: .standard(proto: "game_engines"),
    20: .standard(proto: "game_modes"),
    21: .same(proto: "genres"),
    22: .same(proto: "hypes"),
    23: .standard(proto: "involved_companies"),
    24: .same(proto: "keywords"),
    25: .standard(proto: "multiplayer_modes"),
    26: .same(proto: "name"),
    27: .standard(proto: "parent_game"),
    28: .same(proto: "platforms"),
    29: .standard(proto: "player_perspectives"),
    30: .same(proto: "rating"),
    31: .standard(proto: "rating_count"),
    32: .standard(proto: "release_dates"),
    33: .same(proto: "screenshots"),
    34: .standard(proto: "similar_games"),
    35: .same(proto: "slug"),
    36: .standard(proto: "standalone_expansions"),
    37: .same(proto: "status"),
    38: .same(proto: "storyline"),
    39: .same(proto: "summary"),
    40: .same(proto: "tags"),
    41: .same(proto: "themes"),
    42: .standard(proto: "total_rating"),
    43: .standard(proto: "total_rating_count"),
    44: .standard(proto: "updated_at"),
    45: .same(proto: "url"),
    46: .standard(proto: "version_parent"),
    47: .standard(proto: "version_title"),
    48: .same(proto: "videos"),
    49: .same(proto: "websites"),
    50: .same(proto: "checksum"),
    51: .same(proto: "remakes"),
    52: .same(proto: "remasters"),
    53: .standard(proto: "expanded_games"),
    54: .same(proto: "ports"),
    55: .same(proto: "forks"),
    56: .standard(proto: "language_supports"),
    57: .standard(proto: "game_localizations"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _ageRatings: [Proto_AgeRating] = []
    var _aggregatedRating: Double = 0
    var _aggregatedRatingCount: Int32 = 0
    var _alternativeNames: [Proto_AlternativeName] = []
    var _artworks: [Proto_Artwork] = []
    var _bundles: [Proto_Game] = []
    var _category: Proto_GameCategoryEnum = .mainGame
    var _collection: Proto_Collection? = nil
    var _cover: Proto_Cover? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dlcs: [Proto_Game] = []
    var _expansions: [Proto_Game] = []
    var _externalGames: [Proto_ExternalGame] = []
    var _firstReleaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _follows: Int32 = 0
    var _franchise: Proto_Franchise? = nil
    var _franchises: [Proto_Franchise] = []
    var _gameEngines: [Proto_GameEngine] = []
    var _gameModes: [Proto_GameMode] = []
    var _genres: [Proto_Genre] = []
    var _hypes: Int32 = 0
    var _involvedCompanies: [Proto_InvolvedCompany] = []
    var _keywords: [Proto_Keyword] = []
    var _multiplayerModes: [Proto_MultiplayerMode] = []
    var _name: String = String()
    var _parentGame: Proto_Game? = nil
    var _platforms: [Proto_Platform] = []
    var _playerPerspectives: [Proto_PlayerPerspective] = []
    var _rating: Double = 0
    var _ratingCount: Int32 = 0
    var _releaseDates: [Proto_ReleaseDate] = []
    var _screenshots: [Proto_Screenshot] = []
    var _similarGames: [Proto_Game] = []
    var _slug: String = String()
    var _standaloneExpansions: [Proto_Game] = []
    var _status: Proto_GameStatusEnum = .released
    var _storyline: String = String()
    var _summary: String = String()
    var _tags: [Int32] = []
    var _themes: [Proto_Theme] = []
    var _totalRating: Double = 0
    var _totalRatingCount: Int32 = 0
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _versionParent: Proto_Game? = nil
    var _versionTitle: String = String()
    var _videos: [Proto_GameVideo] = []
    var _websites: [Proto_Website] = []
    var _checksum: String = String()
    var _remakes: [Proto_Game] = []
    var _remasters: [Proto_Game] = []
    var _expandedGames: [Proto_Game] = []
    var _ports: [Proto_Game] = []
    var _forks: [Proto_Game] = []
    var _languageSupports: [Proto_LanguageSupport] = []
    var _gameLocalizations: [Proto_GameLocalization] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _ageRatings = source._ageRatings
      _aggregatedRating = source._aggregatedRating
      _aggregatedRatingCount = source._aggregatedRatingCount
      _alternativeNames = source._alternativeNames
      _artworks = source._artworks
      _bundles = source._bundles
      _category = source._category
      _collection = source._collection
      _cover = source._cover
      _createdAt = source._createdAt
      _dlcs = source._dlcs
      _expansions = source._expansions
      _externalGames = source._externalGames
      _firstReleaseDate = source._firstReleaseDate
      _follows = source._follows
      _franchise = source._franchise
      _franchises = source._franchises
      _gameEngines = source._gameEngines
      _gameModes = source._gameModes
      _genres = source._genres
      _hypes = source._hypes
      _involvedCompanies = source._involvedCompanies
      _keywords = source._keywords
      _multiplayerModes = source._multiplayerModes
      _name = source._name
      _parentGame = source._parentGame
      _platforms = source._platforms
      _playerPerspectives = source._playerPerspectives
      _rating = source._rating
      _ratingCount = source._ratingCount
      _releaseDates = source._releaseDates
      _screenshots = source._screenshots
      _similarGames = source._similarGames
      _slug = source._slug
      _standaloneExpansions = source._standaloneExpansions
      _status = source._status
      _storyline = source._storyline
      _summary = source._summary
      _tags = source._tags
      _themes = source._themes
      _totalRating = source._totalRating
      _totalRatingCount = source._totalRatingCount
      _updatedAt = source._updatedAt
      _url = source._url
      _versionParent = source._versionParent
      _versionTitle = source._versionTitle
      _videos = source._videos
      _websites = source._websites
      _checksum = source._checksum
      _remakes = source._remakes
      _remasters = source._remasters
      _expandedGames = source._expandedGames
      _ports = source._ports
      _forks = source._forks
      _languageSupports = source._languageSupports
      _gameLocalizations = source._gameLocalizations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._ageRatings) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._aggregatedRating) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._aggregatedRatingCount) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._alternativeNames) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._artworks) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._bundles) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._collection) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._cover) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._dlcs) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._expansions) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._externalGames) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._firstReleaseDate) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._follows) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._franchise) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._franchises) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._gameEngines) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._gameModes) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._genres) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._hypes) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._involvedCompanies) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._keywords) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._multiplayerModes) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._parentGame) }()
        case 28: try { try decoder.decodeRepeatedMessageField(value: &_storage._platforms) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._playerPerspectives) }()
        case 30: try { try decoder.decodeSingularDoubleField(value: &_storage._rating) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._ratingCount) }()
        case 32: try { try decoder.decodeRepeatedMessageField(value: &_storage._releaseDates) }()
        case 33: try { try decoder.decodeRepeatedMessageField(value: &_storage._screenshots) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._similarGames) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 36: try { try decoder.decodeRepeatedMessageField(value: &_storage._standaloneExpansions) }()
        case 37: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._storyline) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 40: try { try decoder.decodeRepeatedInt32Field(value: &_storage._tags) }()
        case 41: try { try decoder.decodeRepeatedMessageField(value: &_storage._themes) }()
        case 42: try { try decoder.decodeSingularDoubleField(value: &_storage._totalRating) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._totalRatingCount) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._versionParent) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._versionTitle) }()
        case 48: try { try decoder.decodeRepeatedMessageField(value: &_storage._videos) }()
        case 49: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        case 51: try { try decoder.decodeRepeatedMessageField(value: &_storage._remakes) }()
        case 52: try { try decoder.decodeRepeatedMessageField(value: &_storage._remasters) }()
        case 53: try { try decoder.decodeRepeatedMessageField(value: &_storage._expandedGames) }()
        case 54: try { try decoder.decodeRepeatedMessageField(value: &_storage._ports) }()
        case 55: try { try decoder.decodeRepeatedMessageField(value: &_storage._forks) }()
        case 56: try { try decoder.decodeRepeatedMessageField(value: &_storage._languageSupports) }()
        case 57: try { try decoder.decodeRepeatedMessageField(value: &_storage._gameLocalizations) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._ageRatings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ageRatings, fieldNumber: 2)
      }
      if _storage._aggregatedRating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._aggregatedRating, fieldNumber: 3)
      }
      if _storage._aggregatedRatingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._aggregatedRatingCount, fieldNumber: 4)
      }
      if !_storage._alternativeNames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._alternativeNames, fieldNumber: 5)
      }
      if !_storage._artworks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._artworks, fieldNumber: 6)
      }
      if !_storage._bundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bundles, fieldNumber: 7)
      }
      if _storage._category != .mainGame {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 8)
      }
      try { if let v = _storage._collection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._cover {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._dlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dlcs, fieldNumber: 12)
      }
      if !_storage._expansions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expansions, fieldNumber: 13)
      }
      if !_storage._externalGames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._externalGames, fieldNumber: 14)
      }
      try { if let v = _storage._firstReleaseDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._follows != 0 {
        try visitor.visitSingularInt32Field(value: _storage._follows, fieldNumber: 16)
      }
      try { if let v = _storage._franchise {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._franchises.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._franchises, fieldNumber: 18)
      }
      if !_storage._gameEngines.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameEngines, fieldNumber: 19)
      }
      if !_storage._gameModes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameModes, fieldNumber: 20)
      }
      if !_storage._genres.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._genres, fieldNumber: 21)
      }
      if _storage._hypes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._hypes, fieldNumber: 22)
      }
      if !_storage._involvedCompanies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._involvedCompanies, fieldNumber: 23)
      }
      if !_storage._keywords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keywords, fieldNumber: 24)
      }
      if !_storage._multiplayerModes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._multiplayerModes, fieldNumber: 25)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 26)
      }
      try { if let v = _storage._parentGame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      if !_storage._platforms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platforms, fieldNumber: 28)
      }
      if !_storage._playerPerspectives.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerPerspectives, fieldNumber: 29)
      }
      if _storage._rating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rating, fieldNumber: 30)
      }
      if _storage._ratingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ratingCount, fieldNumber: 31)
      }
      if !_storage._releaseDates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._releaseDates, fieldNumber: 32)
      }
      if !_storage._screenshots.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._screenshots, fieldNumber: 33)
      }
      if !_storage._similarGames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._similarGames, fieldNumber: 34)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 35)
      }
      if !_storage._standaloneExpansions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._standaloneExpansions, fieldNumber: 36)
      }
      if _storage._status != .released {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 37)
      }
      if !_storage._storyline.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storyline, fieldNumber: 38)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 39)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._tags, fieldNumber: 40)
      }
      if !_storage._themes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._themes, fieldNumber: 41)
      }
      if _storage._totalRating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalRating, fieldNumber: 42)
      }
      if _storage._totalRatingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalRatingCount, fieldNumber: 43)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 45)
      }
      try { if let v = _storage._versionParent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      if !_storage._versionTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionTitle, fieldNumber: 47)
      }
      if !_storage._videos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._videos, fieldNumber: 48)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 49)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 50)
      }
      if !_storage._remakes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._remakes, fieldNumber: 51)
      }
      if !_storage._remasters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._remasters, fieldNumber: 52)
      }
      if !_storage._expandedGames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expandedGames, fieldNumber: 53)
      }
      if !_storage._ports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ports, fieldNumber: 54)
      }
      if !_storage._forks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._forks, fieldNumber: 55)
      }
      if !_storage._languageSupports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._languageSupports, fieldNumber: 56)
      }
      if !_storage._gameLocalizations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameLocalizations, fieldNumber: 57)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Game, rhs: Proto_Game) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._ageRatings != rhs_storage._ageRatings {return false}
        if _storage._aggregatedRating != rhs_storage._aggregatedRating {return false}
        if _storage._aggregatedRatingCount != rhs_storage._aggregatedRatingCount {return false}
        if _storage._alternativeNames != rhs_storage._alternativeNames {return false}
        if _storage._artworks != rhs_storage._artworks {return false}
        if _storage._bundles != rhs_storage._bundles {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._cover != rhs_storage._cover {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._dlcs != rhs_storage._dlcs {return false}
        if _storage._expansions != rhs_storage._expansions {return false}
        if _storage._externalGames != rhs_storage._externalGames {return false}
        if _storage._firstReleaseDate != rhs_storage._firstReleaseDate {return false}
        if _storage._follows != rhs_storage._follows {return false}
        if _storage._franchise != rhs_storage._franchise {return false}
        if _storage._franchises != rhs_storage._franchises {return false}
        if _storage._gameEngines != rhs_storage._gameEngines {return false}
        if _storage._gameModes != rhs_storage._gameModes {return false}
        if _storage._genres != rhs_storage._genres {return false}
        if _storage._hypes != rhs_storage._hypes {return false}
        if _storage._involvedCompanies != rhs_storage._involvedCompanies {return false}
        if _storage._keywords != rhs_storage._keywords {return false}
        if _storage._multiplayerModes != rhs_storage._multiplayerModes {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._parentGame != rhs_storage._parentGame {return false}
        if _storage._platforms != rhs_storage._platforms {return false}
        if _storage._playerPerspectives != rhs_storage._playerPerspectives {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._ratingCount != rhs_storage._ratingCount {return false}
        if _storage._releaseDates != rhs_storage._releaseDates {return false}
        if _storage._screenshots != rhs_storage._screenshots {return false}
        if _storage._similarGames != rhs_storage._similarGames {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._standaloneExpansions != rhs_storage._standaloneExpansions {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._storyline != rhs_storage._storyline {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._themes != rhs_storage._themes {return false}
        if _storage._totalRating != rhs_storage._totalRating {return false}
        if _storage._totalRatingCount != rhs_storage._totalRatingCount {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._versionParent != rhs_storage._versionParent {return false}
        if _storage._versionTitle != rhs_storage._versionTitle {return false}
        if _storage._videos != rhs_storage._videos {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        if _storage._remakes != rhs_storage._remakes {return false}
        if _storage._remasters != rhs_storage._remasters {return false}
        if _storage._expandedGames != rhs_storage._expandedGames {return false}
        if _storage._ports != rhs_storage._ports {return false}
        if _storage._forks != rhs_storage._forks {return false}
        if _storage._languageSupports != rhs_storage._languageSupports {return false}
        if _storage._gameLocalizations != rhs_storage._gameLocalizations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameengines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameengines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameengines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameengines, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineResult, rhs: Proto_GameEngineResult) -> Bool {
    if lhs.gameengines != rhs.gameengines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "companies"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "description"),
    5: .same(proto: "logo"),
    6: .same(proto: "name"),
    7: .same(proto: "platforms"),
    8: .same(proto: "slug"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "url"),
    11: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _companies: [Proto_Company] = []
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _logo: Proto_GameEngineLogo? = nil
    var _name: String = String()
    var _platforms: [Proto_Platform] = []
    var _slug: String = String()
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _companies = source._companies
      _createdAt = source._createdAt
      _description_p = source._description_p
      _logo = source._logo
      _name = source._name
      _platforms = source._platforms
      _slug = source._slug
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._logo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._platforms) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._companies, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      try { if let v = _storage._logo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if !_storage._platforms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platforms, fieldNumber: 7)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 8)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 10)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngine, rhs: Proto_GameEngine) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._logo != rhs_storage._logo {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platforms != rhs_storage._platforms {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameenginelogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameenginelogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameenginelogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameenginelogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineLogoResult, rhs: Proto_GameEngineLogoResult) -> Bool {
    if lhs.gameenginelogos != rhs.gameenginelogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineLogo, rhs: Proto_GameEngineLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameLocalizationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameLocalizationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamelocalizations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gamelocalizations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gamelocalizations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gamelocalizations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameLocalizationResult, rhs: Proto_GameLocalizationResult) -> Bool {
    if lhs.gamelocalizations != rhs.gamelocalizations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameLocalization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameLocalization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "cover"),
    4: .same(proto: "game"),
    5: .same(proto: "region"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
    8: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _name: String = String()
    var _cover: Proto_Cover? = nil
    var _game: Proto_Game? = nil
    var _region: Proto_Region? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _cover = source._cover
      _game = source._game
      _region = source._region
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._cover) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._region) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._cover {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._region {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameLocalization, rhs: Proto_GameLocalization) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._cover != rhs_storage._cover {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameModeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameModeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamemodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gamemodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gamemodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gamemodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameModeResult, rhs: Proto_GameModeResult) -> Bool {
    if lhs.gamemodes != rhs.gamemodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameMode, rhs: Proto_GameMode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionResult, rhs: Proto_GameVersionResult) -> Bool {
    if lhs.gameversions != rhs.gameversions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "features"),
    4: .same(proto: "game"),
    5: .same(proto: "games"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 3)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 5)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersion, rhs: Proto_GameVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.features != rhs.features {return false}
    if lhs._game != rhs._game {return false}
    if lhs.games != rhs.games {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversionfeatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversionfeatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversionfeatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversionfeatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureResult, rhs: Proto_GameVersionFeatureResult) -> Bool {
    if lhs.gameversionfeatures != rhs.gameversionfeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "description"),
    4: .same(proto: "position"),
    5: .same(proto: "title"),
    6: .same(proto: "values"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .boolean {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeature, rhs: Proto_GameVersionFeature) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.position != rhs.position {return false}
    if lhs.title != rhs.title {return false}
    if lhs.values != rhs.values {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureValueResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureValueResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversionfeaturevalues"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversionfeaturevalues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversionfeaturevalues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversionfeaturevalues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureValueResult, rhs: Proto_GameVersionFeatureValueResult) -> Bool {
    if lhs.gameversionfeaturevalues != rhs.gameversionfeaturevalues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "game"),
    3: .standard(proto: "game_feature"),
    4: .standard(proto: "included_feature"),
    5: .same(proto: "note"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gameFeature) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.includedFeature) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gameFeature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.includedFeature != .notIncluded {
      try visitor.visitSingularEnumField(value: self.includedFeature, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureValue, rhs: Proto_GameVersionFeatureValue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._game != rhs._game {return false}
    if lhs._gameFeature != rhs._gameFeature {return false}
    if lhs.includedFeature != rhs.includedFeature {return false}
    if lhs.note != rhs.note {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVideoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVideoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamevideos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gamevideos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gamevideos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gamevideos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVideoResult, rhs: Proto_GameVideoResult) -> Bool {
    if lhs.gamevideos != rhs.gamevideos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "game"),
    3: .same(proto: "name"),
    4: .standard(proto: "video_id"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.videoID.isEmpty {
      try visitor.visitSingularStringField(value: self.videoID, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVideo, rhs: Proto_GameVideo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.videoID != rhs.videoID {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GenreResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenreResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "genres"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.genres) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.genres.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.genres, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GenreResult, rhs: Proto_GenreResult) -> Bool {
    if lhs.genres != rhs.genres {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Genre: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Genre"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Genre, rhs: Proto_Genre) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InvolvedCompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvolvedCompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "involvedcompanies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.involvedcompanies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.involvedcompanies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.involvedcompanies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_InvolvedCompanyResult, rhs: Proto_InvolvedCompanyResult) -> Bool {
    if lhs.involvedcompanies != rhs.involvedcompanies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InvolvedCompany: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvolvedCompany"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "company"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "developer"),
    5: .same(proto: "game"),
    6: .same(proto: "porting"),
    7: .same(proto: "publisher"),
    8: .same(proto: "supporting"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._company) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.developer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.porting) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.publisher) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supporting) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._company {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.developer != false {
      try visitor.visitSingularBoolField(value: self.developer, fieldNumber: 4)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.porting != false {
      try visitor.visitSingularBoolField(value: self.porting, fieldNumber: 6)
    }
    if self.publisher != false {
      try visitor.visitSingularBoolField(value: self.publisher, fieldNumber: 7)
    }
    if self.supporting != false {
      try visitor.visitSingularBoolField(value: self.supporting, fieldNumber: 8)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_InvolvedCompany, rhs: Proto_InvolvedCompany) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._company != rhs._company {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.developer != rhs.developer {return false}
    if lhs._game != rhs._game {return false}
    if lhs.porting != rhs.porting {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.supporting != rhs.supporting {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeywordResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeywordResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keywords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keywords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keywords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keywords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_KeywordResult, rhs: Proto_KeywordResult) -> Bool {
    if lhs.keywords != rhs.keywords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Keyword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Keyword"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Keyword, rhs: Proto_Keyword) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_LanguageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_LanguageResult, rhs: Proto_LanguageResult) -> Bool {
    if lhs.languages != rhs.languages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Language: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Language"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "native_name"),
    4: .same(proto: "locale"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nativeName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.nativeName.isEmpty {
      try visitor.visitSingularStringField(value: self.nativeName, fieldNumber: 3)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Language, rhs: Proto_Language) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.nativeName != rhs.nativeName {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_LanguageSupportResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageSupportResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languagesupports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languagesupports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languagesupports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languagesupports, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_LanguageSupportResult, rhs: Proto_LanguageSupportResult) -> Bool {
    if lhs.languagesupports != rhs.languagesupports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_LanguageSupport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageSupport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "game"),
    3: .same(proto: "language"),
    4: .standard(proto: "language_support_type"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _game: Proto_Game? = nil
    var _language: Proto_Language? = nil
    var _languageSupportType: Proto_LanguageSupportType? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _game = source._game
      _language = source._language
      _languageSupportType = source._languageSupportType
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._language) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._languageSupportType) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._language {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._languageSupportType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_LanguageSupport, rhs: Proto_LanguageSupport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._languageSupportType != rhs_storage._languageSupportType {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_LanguageSupportTypeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageSupportTypeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languagesupporttypes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.languagesupporttypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languagesupporttypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.languagesupporttypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_LanguageSupportTypeResult, rhs: Proto_LanguageSupportTypeResult) -> Bool {
    if lhs.languagesupporttypes != rhs.languagesupporttypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_LanguageSupportType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageSupportType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_LanguageSupportType, rhs: Proto_LanguageSupportType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiplayerModeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplayerModeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multiplayermodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.multiplayermodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.multiplayermodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.multiplayermodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiplayerModeResult, rhs: Proto_MultiplayerModeResult) -> Bool {
    if lhs.multiplayermodes != rhs.multiplayermodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiplayerMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplayerMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "campaigncoop"),
    3: .same(proto: "dropin"),
    4: .same(proto: "game"),
    5: .same(proto: "lancoop"),
    6: .same(proto: "offlinecoop"),
    7: .same(proto: "offlinecoopmax"),
    8: .same(proto: "offlinemax"),
    9: .same(proto: "onlinecoop"),
    10: .same(proto: "onlinecoopmax"),
    11: .same(proto: "onlinemax"),
    12: .same(proto: "platform"),
    13: .same(proto: "splitscreen"),
    14: .same(proto: "splitscreenonline"),
    15: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.campaigncoop) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.dropin) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lancoop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.offlinecoop) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.offlinecoopmax) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.offlinemax) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.onlinecoop) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.onlinecoopmax) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.onlinemax) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.splitscreen) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.splitscreenonline) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.campaigncoop != false {
      try visitor.visitSingularBoolField(value: self.campaigncoop, fieldNumber: 2)
    }
    if self.dropin != false {
      try visitor.visitSingularBoolField(value: self.dropin, fieldNumber: 3)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.lancoop != false {
      try visitor.visitSingularBoolField(value: self.lancoop, fieldNumber: 5)
    }
    if self.offlinecoop != false {
      try visitor.visitSingularBoolField(value: self.offlinecoop, fieldNumber: 6)
    }
    if self.offlinecoopmax != 0 {
      try visitor.visitSingularInt32Field(value: self.offlinecoopmax, fieldNumber: 7)
    }
    if self.offlinemax != 0 {
      try visitor.visitSingularInt32Field(value: self.offlinemax, fieldNumber: 8)
    }
    if self.onlinecoop != false {
      try visitor.visitSingularBoolField(value: self.onlinecoop, fieldNumber: 9)
    }
    if self.onlinecoopmax != 0 {
      try visitor.visitSingularInt32Field(value: self.onlinecoopmax, fieldNumber: 10)
    }
    if self.onlinemax != 0 {
      try visitor.visitSingularInt32Field(value: self.onlinemax, fieldNumber: 11)
    }
    try { if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if self.splitscreen != false {
      try visitor.visitSingularBoolField(value: self.splitscreen, fieldNumber: 13)
    }
    if self.splitscreenonline != false {
      try visitor.visitSingularBoolField(value: self.splitscreenonline, fieldNumber: 14)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiplayerMode, rhs: Proto_MultiplayerMode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.campaigncoop != rhs.campaigncoop {return false}
    if lhs.dropin != rhs.dropin {return false}
    if lhs._game != rhs._game {return false}
    if lhs.lancoop != rhs.lancoop {return false}
    if lhs.offlinecoop != rhs.offlinecoop {return false}
    if lhs.offlinecoopmax != rhs.offlinecoopmax {return false}
    if lhs.offlinemax != rhs.offlinemax {return false}
    if lhs.onlinecoop != rhs.onlinecoop {return false}
    if lhs.onlinecoopmax != rhs.onlinecoopmax {return false}
    if lhs.onlinemax != rhs.onlinemax {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.splitscreen != rhs.splitscreen {return false}
    if lhs.splitscreenonline != rhs.splitscreenonline {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platforms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platforms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platforms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platforms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformResult, rhs: Proto_PlatformResult) -> Bool {
    if lhs.platforms != rhs.platforms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "abbreviation"),
    3: .standard(proto: "alternative_name"),
    4: .same(proto: "category"),
    5: .standard(proto: "created_at"),
    6: .same(proto: "generation"),
    7: .same(proto: "name"),
    8: .standard(proto: "platform_logo"),
    9: .standard(proto: "platform_family"),
    10: .same(proto: "slug"),
    11: .same(proto: "summary"),
    12: .standard(proto: "updated_at"),
    13: .same(proto: "url"),
    14: .same(proto: "versions"),
    15: .same(proto: "websites"),
    16: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _abbreviation: String = String()
    var _alternativeName: String = String()
    var _category: Proto_PlatformCategoryEnum = .platformCategoryNull
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _generation: Int32 = 0
    var _name: String = String()
    var _platformLogo: Proto_PlatformLogo? = nil
    var _platformFamily: Proto_PlatformFamily? = nil
    var _slug: String = String()
    var _summary: String = String()
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _versions: [Proto_PlatformVersion] = []
    var _websites: [Proto_PlatformWebsite] = []
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _abbreviation = source._abbreviation
      _alternativeName = source._alternativeName
      _category = source._category
      _createdAt = source._createdAt
      _generation = source._generation
      _name = source._name
      _platformLogo = source._platformLogo
      _platformFamily = source._platformFamily
      _slug = source._slug
      _summary = source._summary
      _updatedAt = source._updatedAt
      _url = source._url
      _versions = source._versions
      _websites = source._websites
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._abbreviation) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._alternativeName) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._generation) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._platformLogo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._platformFamily) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._versions) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._abbreviation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._abbreviation, fieldNumber: 2)
      }
      if !_storage._alternativeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alternativeName, fieldNumber: 3)
      }
      if _storage._category != .platformCategoryNull {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 4)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._generation != 0 {
        try visitor.visitSingularInt32Field(value: _storage._generation, fieldNumber: 6)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 7)
      }
      try { if let v = _storage._platformLogo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._platformFamily {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 10)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 11)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 13)
      }
      if !_storage._versions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versions, fieldNumber: 14)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 15)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Platform, rhs: Proto_Platform) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._abbreviation != rhs_storage._abbreviation {return false}
        if _storage._alternativeName != rhs_storage._alternativeName {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platformLogo != rhs_storage._platformLogo {return false}
        if _storage._platformFamily != rhs_storage._platformFamily {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._versions != rhs_storage._versions {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformFamilyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformFamilyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformfamilies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformfamilies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformfamilies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformfamilies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformFamilyResult, rhs: Proto_PlatformFamilyResult) -> Bool {
    if lhs.platformfamilies != rhs.platformfamilies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformFamily"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "slug"),
    4: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 3)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformFamily, rhs: Proto_PlatformFamily) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformlogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformlogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformlogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformlogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformLogoResult, rhs: Proto_PlatformLogoResult) -> Bool {
    if lhs.platformlogos != rhs.platformlogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformLogo, rhs: Proto_PlatformLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionResult, rhs: Proto_PlatformVersionResult) -> Bool {
    if lhs.platformversions != rhs.platformversions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "companies"),
    3: .same(proto: "connectivity"),
    4: .same(proto: "cpu"),
    5: .same(proto: "graphics"),
    6: .standard(proto: "main_manufacturer"),
    7: .same(proto: "media"),
    8: .same(proto: "memory"),
    9: .same(proto: "name"),
    10: .same(proto: "online"),
    11: .same(proto: "os"),
    12: .same(proto: "output"),
    13: .standard(proto: "platform_logo"),
    14: .standard(proto: "platform_version_release_dates"),
    15: .same(proto: "resolutions"),
    16: .same(proto: "slug"),
    17: .same(proto: "sound"),
    18: .same(proto: "storage"),
    19: .same(proto: "summary"),
    20: .same(proto: "url"),
    21: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _companies: [Proto_PlatformVersionCompany] = []
    var _connectivity: String = String()
    var _cpu: String = String()
    var _graphics: String = String()
    var _mainManufacturer: Proto_PlatformVersionCompany? = nil
    var _media: String = String()
    var _memory: String = String()
    var _name: String = String()
    var _online: String = String()
    var _os: String = String()
    var _output: String = String()
    var _platformLogo: Proto_PlatformLogo? = nil
    var _platformVersionReleaseDates: [Proto_PlatformVersionReleaseDate] = []
    var _resolutions: String = String()
    var _slug: String = String()
    var _sound: String = String()
    var _storage: String = String()
    var _summary: String = String()
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _companies = source._companies
      _connectivity = source._connectivity
      _cpu = source._cpu
      _graphics = source._graphics
      _mainManufacturer = source._mainManufacturer
      _media = source._media
      _memory = source._memory
      _name = source._name
      _online = source._online
      _os = source._os
      _output = source._output
      _platformLogo = source._platformLogo
      _platformVersionReleaseDates = source._platformVersionReleaseDates
      _resolutions = source._resolutions
      _slug = source._slug
      _sound = source._sound
      _storage = source._storage
      _summary = source._summary
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._connectivity) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._cpu) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._graphics) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._mainManufacturer) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._media) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._memory) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._online) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._os) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._output) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._platformLogo) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._platformVersionReleaseDates) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._resolutions) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._sound) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._storage) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._companies, fieldNumber: 2)
      }
      if !_storage._connectivity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectivity, fieldNumber: 3)
      }
      if !_storage._cpu.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cpu, fieldNumber: 4)
      }
      if !_storage._graphics.isEmpty {
        try visitor.visitSingularStringField(value: _storage._graphics, fieldNumber: 5)
      }
      try { if let v = _storage._mainManufacturer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._media.isEmpty {
        try visitor.visitSingularStringField(value: _storage._media, fieldNumber: 7)
      }
      if !_storage._memory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memory, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._online.isEmpty {
        try visitor.visitSingularStringField(value: _storage._online, fieldNumber: 10)
      }
      if !_storage._os.isEmpty {
        try visitor.visitSingularStringField(value: _storage._os, fieldNumber: 11)
      }
      if !_storage._output.isEmpty {
        try visitor.visitSingularStringField(value: _storage._output, fieldNumber: 12)
      }
      try { if let v = _storage._platformLogo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._platformVersionReleaseDates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platformVersionReleaseDates, fieldNumber: 14)
      }
      if !_storage._resolutions.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resolutions, fieldNumber: 15)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 16)
      }
      if !_storage._sound.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sound, fieldNumber: 17)
      }
      if !_storage._storage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storage, fieldNumber: 18)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 19)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 20)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersion, rhs: Proto_PlatformVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._connectivity != rhs_storage._connectivity {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._graphics != rhs_storage._graphics {return false}
        if _storage._mainManufacturer != rhs_storage._mainManufacturer {return false}
        if _storage._media != rhs_storage._media {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._os != rhs_storage._os {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._platformLogo != rhs_storage._platformLogo {return false}
        if _storage._platformVersionReleaseDates != rhs_storage._platformVersionReleaseDates {return false}
        if _storage._resolutions != rhs_storage._resolutions {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._sound != rhs_storage._sound {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionCompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionCompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversioncompanies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversioncompanies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversioncompanies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversioncompanies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionCompanyResult, rhs: Proto_PlatformVersionCompanyResult) -> Bool {
    if lhs.platformversioncompanies != rhs.platformversioncompanies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionCompany: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionCompany"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "comment"),
    3: .same(proto: "company"),
    4: .same(proto: "developer"),
    5: .same(proto: "manufacturer"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._company) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.developer) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.manufacturer) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    try { if let v = self._company {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.developer != false {
      try visitor.visitSingularBoolField(value: self.developer, fieldNumber: 4)
    }
    if self.manufacturer != false {
      try visitor.visitSingularBoolField(value: self.manufacturer, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionCompany, rhs: Proto_PlatformVersionCompany) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._company != rhs._company {return false}
    if lhs.developer != rhs.developer {return false}
    if lhs.manufacturer != rhs.manufacturer {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionReleaseDateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionReleaseDateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversionreleasedates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversionreleasedates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversionreleasedates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversionreleasedates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionReleaseDateResult, rhs: Proto_PlatformVersionReleaseDateResult) -> Bool {
    if lhs.platformversionreleasedates != rhs.platformversionreleasedates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionReleaseDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionReleaseDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "date"),
    5: .same(proto: "human"),
    6: .same(proto: "m"),
    7: .standard(proto: "platform_version"),
    8: .same(proto: "region"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "y"),
    11: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.human) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.m) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._platformVersion) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .yyyymmmmdd {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.human.isEmpty {
      try visitor.visitSingularStringField(value: self.human, fieldNumber: 5)
    }
    if self.m != 0 {
      try visitor.visitSingularInt32Field(value: self.m, fieldNumber: 6)
    }
    try { if let v = self._platformVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.region != .regionRegionNull {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 8)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 10)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionReleaseDate, rhs: Proto_PlatformVersionReleaseDate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._date != rhs._date {return false}
    if lhs.human != rhs.human {return false}
    if lhs.m != rhs.m {return false}
    if lhs._platformVersion != rhs._platformVersion {return false}
    if lhs.region != rhs.region {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.y != rhs.y {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformWebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformWebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformwebsites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformwebsites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformwebsites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformwebsites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformWebsiteResult, rhs: Proto_PlatformWebsiteResult) -> Bool {
    if lhs.platformwebsites != rhs.platformwebsites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformWebsite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformWebsite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "trusted"),
    4: .same(proto: "url"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformWebsite, rhs: Proto_PlatformWebsite) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlayerPerspectiveResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayerPerspectiveResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playerperspectives"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.playerperspectives) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playerperspectives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playerperspectives, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlayerPerspectiveResult, rhs: Proto_PlayerPerspectiveResult) -> Bool {
    if lhs.playerperspectives != rhs.playerperspectives {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlayerPerspective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayerPerspective"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlayerPerspective, rhs: Proto_PlayerPerspective) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RegionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.regions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_RegionResult, rhs: Proto_RegionResult) -> Bool {
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Region"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "category"),
    4: .same(proto: "identifier"),
    5: .standard(proto: "created_at"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 3)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Region, rhs: Proto_Region) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.category != rhs.category {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "releasedates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.releasedates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.releasedates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.releasedates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDateResult, rhs: Proto_ReleaseDateResult) -> Bool {
    if lhs.releasedates != rhs.releasedates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "date"),
    5: .same(proto: "game"),
    6: .same(proto: "human"),
    7: .same(proto: "m"),
    8: .same(proto: "platform"),
    9: .same(proto: "region"),
    10: .standard(proto: "updated_at"),
    11: .same(proto: "y"),
    12: .same(proto: "checksum"),
    13: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _category: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _game: Proto_Game? = nil
    var _human: String = String()
    var _m: Int32 = 0
    var _platform: Proto_Platform? = nil
    var _region: Proto_RegionRegionEnum = .regionRegionNull
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _y: Int32 = 0
    var _checksum: String = String()
    var _status: Proto_ReleaseDateStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _category = source._category
      _createdAt = source._createdAt
      _date = source._date
      _game = source._game
      _human = source._human
      _m = source._m
      _platform = source._platform
      _region = source._region
      _updatedAt = source._updatedAt
      _y = source._y
      _checksum = source._checksum
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._human) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._m) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._platform) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._region) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._y) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._category != .yyyymmmmdd {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._human.isEmpty {
        try visitor.visitSingularStringField(value: _storage._human, fieldNumber: 6)
      }
      if _storage._m != 0 {
        try visitor.visitSingularInt32Field(value: _storage._m, fieldNumber: 7)
      }
      try { if let v = _storage._platform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._region != .regionRegionNull {
        try visitor.visitSingularEnumField(value: _storage._region, fieldNumber: 9)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._y != 0 {
        try visitor.visitSingularInt32Field(value: _storage._y, fieldNumber: 11)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 12)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDate, rhs: Proto_ReleaseDate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._human != rhs_storage._human {return false}
        if _storage._m != rhs_storage._m {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDateStatusResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDateStatusResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "releasedatestatuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.releasedatestatuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.releasedatestatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.releasedatestatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDateStatusResult, rhs: Proto_ReleaseDateStatusResult) -> Bool {
    if lhs.releasedatestatuses != rhs.releasedatestatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDateStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDateStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDateStatus, rhs: Proto_ReleaseDateStatus) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ScreenshotResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScreenshotResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screenshots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screenshots) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screenshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screenshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScreenshotResult, rhs: Proto_ScreenshotResult) -> Bool {
    if lhs.screenshots != rhs.screenshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Screenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screenshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 8)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Screenshot, rhs: Proto_Screenshot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs._game != rhs._game {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SearchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "searches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SearchResult, rhs: Proto_SearchResult) -> Bool {
    if lhs.searches != rhs.searches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Search"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alternative_name"),
    3: .same(proto: "character"),
    4: .same(proto: "collection"),
    5: .same(proto: "company"),
    6: .same(proto: "description"),
    7: .same(proto: "game"),
    8: .same(proto: "name"),
    9: .same(proto: "platform"),
    10: .standard(proto: "published_at"),
    11: .standard(proto: "test_dummy"),
    12: .same(proto: "theme"),
    13: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _alternativeName: String = String()
    var _character: Proto_Character? = nil
    var _collection: Proto_Collection? = nil
    var _company: Proto_Company? = nil
    var _description_p: String = String()
    var _game: Proto_Game? = nil
    var _name: String = String()
    var _platform: Proto_Platform? = nil
    var _publishedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _testDummy: Proto_TestDummy? = nil
    var _theme: Proto_Theme? = nil
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _alternativeName = source._alternativeName
      _character = source._character
      _collection = source._collection
      _company = source._company
      _description_p = source._description_p
      _game = source._game
      _name = source._name
      _platform = source._platform
      _publishedAt = source._publishedAt
      _testDummy = source._testDummy
      _theme = source._theme
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._alternativeName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._character) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._collection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._company) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._platform) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._publishedAt) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._testDummy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._alternativeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alternativeName, fieldNumber: 2)
      }
      try { if let v = _storage._character {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._collection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._company {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      try { if let v = _storage._platform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._publishedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._testDummy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Search, rhs: Proto_Search) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._alternativeName != rhs_storage._alternativeName {return false}
        if _storage._character != rhs_storage._character {return false}
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._company != rhs_storage._company {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._publishedAt != rhs_storage._publishedAt {return false}
        if _storage._testDummy != rhs_storage._testDummy {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TestDummyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestDummyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "testdummies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.testdummies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.testdummies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testdummies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TestDummyResult, rhs: Proto_TestDummyResult) -> Bool {
    if lhs.testdummies != rhs.testdummies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TestDummy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestDummy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "bool_value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "enum_test"),
    5: .standard(proto: "float_value"),
    6: .same(proto: "game"),
    7: .standard(proto: "integer_array"),
    8: .standard(proto: "integer_value"),
    9: .same(proto: "name"),
    10: .standard(proto: "new_integer_value"),
    11: .same(proto: "private"),
    12: .same(proto: "slug"),
    13: .standard(proto: "string_array"),
    14: .standard(proto: "test_dummies"),
    15: .standard(proto: "test_dummy"),
    16: .standard(proto: "updated_at"),
    17: .same(proto: "url"),
    18: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _boolValue: Bool = false
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _enumTest: Proto_TestDummyEnumTestEnum = .testdummyEnumTestNull
    var _floatValue: Double = 0
    var _game: Proto_Game? = nil
    var _integerArray: [Int32] = []
    var _integerValue: Int32 = 0
    var _name: String = String()
    var _newIntegerValue: Int32 = 0
    var _private: Bool = false
    var _slug: String = String()
    var _stringArray: [String] = []
    var _testDummies: [Proto_TestDummy] = []
    var _testDummy: Proto_TestDummy? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _boolValue = source._boolValue
      _createdAt = source._createdAt
      _enumTest = source._enumTest
      _floatValue = source._floatValue
      _game = source._game
      _integerArray = source._integerArray
      _integerValue = source._integerValue
      _name = source._name
      _newIntegerValue = source._newIntegerValue
      _private = source._private
      _slug = source._slug
      _stringArray = source._stringArray
      _testDummies = source._testDummies
      _testDummy = source._testDummy
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._enumTest) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._floatValue) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 7: try { try decoder.decodeRepeatedInt32Field(value: &_storage._integerArray) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._integerValue) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._newIntegerValue) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._stringArray) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._testDummies) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._testDummy) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._boolValue != false {
        try visitor.visitSingularBoolField(value: _storage._boolValue, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._enumTest != .testdummyEnumTestNull {
        try visitor.visitSingularEnumField(value: _storage._enumTest, fieldNumber: 4)
      }
      if _storage._floatValue != 0 {
        try visitor.visitSingularDoubleField(value: _storage._floatValue, fieldNumber: 5)
      }
      try { if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._integerArray.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._integerArray, fieldNumber: 7)
      }
      if _storage._integerValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._integerValue, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if _storage._newIntegerValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._newIntegerValue, fieldNumber: 10)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 11)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 12)
      }
      if !_storage._stringArray.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._stringArray, fieldNumber: 13)
      }
      if !_storage._testDummies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testDummies, fieldNumber: 14)
      }
      try { if let v = _storage._testDummy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 17)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TestDummy, rhs: Proto_TestDummy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._enumTest != rhs_storage._enumTest {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._integerArray != rhs_storage._integerArray {return false}
        if _storage._integerValue != rhs_storage._integerValue {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._newIntegerValue != rhs_storage._newIntegerValue {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._stringArray != rhs_storage._stringArray {return false}
        if _storage._testDummies != rhs_storage._testDummies {return false}
        if _storage._testDummy != rhs_storage._testDummy {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThemeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThemeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "themes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.themes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.themes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.themes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThemeResult, rhs: Proto_ThemeResult) -> Bool {
    if lhs.themes != rhs.themes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Theme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Theme"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Theme, rhs: Proto_Theme) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "websites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.websites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.websites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.websites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_WebsiteResult, rhs: Proto_WebsiteResult) -> Bool {
    if lhs.websites != rhs.websites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Website: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Website"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "game"),
    4: .same(proto: "trusted"),
    5: .same(proto: "url"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    try { if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Website, rhs: Proto_Website) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._game != rhs._game {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

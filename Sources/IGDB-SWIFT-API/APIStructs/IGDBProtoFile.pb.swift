// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IGDBProtoFile.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Proto_AgeRatingCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ageratingCategoryNull // = 0
  case esrb // = 1
  case pegi // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .ageratingCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ageratingCategoryNull
    case 1: self = .esrb
    case 2: self = .pegi
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ageratingCategoryNull: return 0
    case .esrb: return 1
    case .pegi: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AgeRatingCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_AgeRatingCategoryEnum] = [
    .ageratingCategoryNull,
    .esrb,
    .pegi,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_AgeRatingRatingEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ageratingRatingNull // = 0
  case three // = 1
  case seven // = 2
  case twelve // = 3
  case sixteen // = 4
  case eighteen // = 5
  case rp // = 6
  case ec // = 7
  case e // = 8
  case e10 // = 9
  case t // = 10
  case m // = 11
  case ao // = 12
  case UNRECOGNIZED(Int)

  public init() {
    self = .ageratingRatingNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ageratingRatingNull
    case 1: self = .three
    case 2: self = .seven
    case 3: self = .twelve
    case 4: self = .sixteen
    case 5: self = .eighteen
    case 6: self = .rp
    case 7: self = .ec
    case 8: self = .e
    case 9: self = .e10
    case 10: self = .t
    case 11: self = .m
    case 12: self = .ao
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ageratingRatingNull: return 0
    case .three: return 1
    case .seven: return 2
    case .twelve: return 3
    case .sixteen: return 4
    case .eighteen: return 5
    case .rp: return 6
    case .ec: return 7
    case .e: return 8
    case .e10: return 9
    case .t: return 10
    case .m: return 11
    case .ao: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_AgeRatingRatingEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_AgeRatingRatingEnum] = [
    .ageratingRatingNull,
    .three,
    .seven,
    .twelve,
    .sixteen,
    .eighteen,
    .rp,
    .ec,
    .e,
    .e10,
    .t,
    .m,
    .ao,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GenderGenderEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case genderGenderNull // = 0
  case male // = 1
  case female // = 2
  case other // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .genderGenderNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genderGenderNull
    case 1: self = .male
    case 2: self = .female
    case 3: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .genderGenderNull: return 0
    case .male: return 1
    case .female: return 2
    case .other: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GenderGenderEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GenderGenderEnum] = [
    .genderGenderNull,
    .male,
    .female,
    .other,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_CharacterSpeciesEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case characterSpeciesNull // = 0
  case human // = 1
  case alien // = 2
  case animal // = 3
  case android // = 4
  case unknown // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .characterSpeciesNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .characterSpeciesNull
    case 1: self = .human
    case 2: self = .alien
    case 3: self = .animal
    case 4: self = .android
    case 5: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .characterSpeciesNull: return 0
    case .human: return 1
    case .alien: return 2
    case .animal: return 3
    case .android: return 4
    case .unknown: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_CharacterSpeciesEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_CharacterSpeciesEnum] = [
    .characterSpeciesNull,
    .human,
    .alien,
    .animal,
    .android,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_DateFormatChangeDateCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case yyyymmmmdd // = 0
  case yyyymmmm // = 1
  case yyyy // = 2
  case yyyyq1 // = 3
  case yyyyq2 // = 4
  case yyyyq3 // = 5
  case yyyyq4 // = 6
  case tbd // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .yyyymmmmdd
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .yyyymmmmdd
    case 1: self = .yyyymmmm
    case 2: self = .yyyy
    case 3: self = .yyyyq1
    case 4: self = .yyyyq2
    case 5: self = .yyyyq3
    case 6: self = .yyyyq4
    case 7: self = .tbd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .yyyymmmmdd: return 0
    case .yyyymmmm: return 1
    case .yyyy: return 2
    case .yyyyq1: return 3
    case .yyyyq2: return 4
    case .yyyyq3: return 5
    case .yyyyq4: return 6
    case .tbd: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DateFormatChangeDateCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_DateFormatChangeDateCategoryEnum] = [
    .yyyymmmmdd,
    .yyyymmmm,
    .yyyy,
    .yyyyq1,
    .yyyyq2,
    .yyyyq3,
    .yyyyq4,
    .tbd,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_WebsiteCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case websiteCategoryNull // = 0
  case websiteOfficial // = 1
  case websiteWikia // = 2
  case websiteWikipedia // = 3
  case websiteFacebook // = 4
  case websiteTwitter // = 5
  case websiteTwitch // = 6
  case websiteInstagram // = 8
  case websiteYoutube // = 9
  case websiteIphone // = 10
  case websiteIpad // = 11
  case websiteAndroid // = 12
  case websiteSteam // = 13
  case websiteReddit // = 14
  case websiteItch // = 15
  case websiteEpicgames // = 16
  case websiteGog // = 17
  case websiteDiscord // = 18
  case UNRECOGNIZED(Int)

  public init() {
    self = .websiteCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .websiteCategoryNull
    case 1: self = .websiteOfficial
    case 2: self = .websiteWikia
    case 3: self = .websiteWikipedia
    case 4: self = .websiteFacebook
    case 5: self = .websiteTwitter
    case 6: self = .websiteTwitch
    case 8: self = .websiteInstagram
    case 9: self = .websiteYoutube
    case 10: self = .websiteIphone
    case 11: self = .websiteIpad
    case 12: self = .websiteAndroid
    case 13: self = .websiteSteam
    case 14: self = .websiteReddit
    case 15: self = .websiteItch
    case 16: self = .websiteEpicgames
    case 17: self = .websiteGog
    case 18: self = .websiteDiscord
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .websiteCategoryNull: return 0
    case .websiteOfficial: return 1
    case .websiteWikia: return 2
    case .websiteWikipedia: return 3
    case .websiteFacebook: return 4
    case .websiteTwitter: return 5
    case .websiteTwitch: return 6
    case .websiteInstagram: return 8
    case .websiteYoutube: return 9
    case .websiteIphone: return 10
    case .websiteIpad: return 11
    case .websiteAndroid: return 12
    case .websiteSteam: return 13
    case .websiteReddit: return 14
    case .websiteItch: return 15
    case .websiteEpicgames: return 16
    case .websiteGog: return 17
    case .websiteDiscord: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_WebsiteCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_WebsiteCategoryEnum] = [
    .websiteCategoryNull,
    .websiteOfficial,
    .websiteWikia,
    .websiteWikipedia,
    .websiteFacebook,
    .websiteTwitter,
    .websiteTwitch,
    .websiteInstagram,
    .websiteYoutube,
    .websiteIphone,
    .websiteIpad,
    .websiteAndroid,
    .websiteSteam,
    .websiteReddit,
    .websiteItch,
    .websiteEpicgames,
    .websiteGog,
    .websiteDiscord,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_ExternalGameCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case externalgameCategoryNull // = 0
  case externalgameSteam // = 1
  case externalgameGog // = 5
  case externalgameYoutube // = 10
  case externalgameMicrosoft // = 11
  case externalgameApple // = 13
  case externalgameTwitch // = 14
  case externalgameAndroid // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .externalgameCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .externalgameCategoryNull
    case 1: self = .externalgameSteam
    case 5: self = .externalgameGog
    case 10: self = .externalgameYoutube
    case 11: self = .externalgameMicrosoft
    case 13: self = .externalgameApple
    case 14: self = .externalgameTwitch
    case 15: self = .externalgameAndroid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .externalgameCategoryNull: return 0
    case .externalgameSteam: return 1
    case .externalgameGog: return 5
    case .externalgameYoutube: return 10
    case .externalgameMicrosoft: return 11
    case .externalgameApple: return 13
    case .externalgameTwitch: return 14
    case .externalgameAndroid: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ExternalGameCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_ExternalGameCategoryEnum] = [
    .externalgameCategoryNull,
    .externalgameSteam,
    .externalgameGog,
    .externalgameYoutube,
    .externalgameMicrosoft,
    .externalgameApple,
    .externalgameTwitch,
    .externalgameAndroid,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_ExternalGameMediaEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case externalgameMediaNull // = 0
  case externalgameDigital // = 1
  case externalgamePhysical // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .externalgameMediaNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .externalgameMediaNull
    case 1: self = .externalgameDigital
    case 2: self = .externalgamePhysical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .externalgameMediaNull: return 0
    case .externalgameDigital: return 1
    case .externalgamePhysical: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ExternalGameMediaEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_ExternalGameMediaEnum] = [
    .externalgameMediaNull,
    .externalgameDigital,
    .externalgamePhysical,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case mainGame // = 0
  case dlcAddon // = 1
  case expansion // = 2
  case bundle // = 3
  case standaloneExpansion // = 4
  case mod // = 5
  case episode // = 6
  case season // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .mainGame
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mainGame
    case 1: self = .dlcAddon
    case 2: self = .expansion
    case 3: self = .bundle
    case 4: self = .standaloneExpansion
    case 5: self = .mod
    case 6: self = .episode
    case 7: self = .season
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mainGame: return 0
    case .dlcAddon: return 1
    case .expansion: return 2
    case .bundle: return 3
    case .standaloneExpansion: return 4
    case .mod: return 5
    case .episode: return 6
    case .season: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameCategoryEnum] = [
    .mainGame,
    .dlcAddon,
    .expansion,
    .bundle,
    .standaloneExpansion,
    .mod,
    .episode,
    .season,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameStatusEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case released // = 0
  case alpha // = 2
  case beta // = 3
  case earlyAccess // = 4
  case offline // = 5
  case cancelled // = 6
  case rumored // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .released
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .released
    case 2: self = .alpha
    case 3: self = .beta
    case 4: self = .earlyAccess
    case 5: self = .offline
    case 6: self = .cancelled
    case 7: self = .rumored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .released: return 0
    case .alpha: return 2
    case .beta: return 3
    case .earlyAccess: return 4
    case .offline: return 5
    case .cancelled: return 6
    case .rumored: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameStatusEnum] = [
    .released,
    .alpha,
    .beta,
    .earlyAccess,
    .offline,
    .cancelled,
    .rumored,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameVersionFeatureCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case boolean // = 0
  case description_ // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .boolean
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .boolean
    case 1: self = .description_
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .boolean: return 0
    case .description_: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameVersionFeatureCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameVersionFeatureCategoryEnum] = [
    .boolean,
    .description_,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_GameVersionFeatureValueIncludedFeatureEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notIncluded // = 0
  case included // = 1
  case preOrderOnly // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notIncluded
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notIncluded
    case 1: self = .included
    case 2: self = .preOrderOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notIncluded: return 0
    case .included: return 1
    case .preOrderOnly: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_GameVersionFeatureValueIncludedFeatureEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_GameVersionFeatureValueIncludedFeatureEnum] = [
    .notIncluded,
    .included,
    .preOrderOnly,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_PlatformCategoryEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case platformCategoryNull // = 0
  case console // = 1
  case arcade // = 2
  case platform // = 3
  case operatingSystem // = 4
  case portableConsole // = 5
  case computer // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .platformCategoryNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .platformCategoryNull
    case 1: self = .console
    case 2: self = .arcade
    case 3: self = .platform
    case 4: self = .operatingSystem
    case 5: self = .portableConsole
    case 6: self = .computer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .platformCategoryNull: return 0
    case .console: return 1
    case .arcade: return 2
    case .platform: return 3
    case .operatingSystem: return 4
    case .portableConsole: return 5
    case .computer: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_PlatformCategoryEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_PlatformCategoryEnum] = [
    .platformCategoryNull,
    .console,
    .arcade,
    .platform,
    .operatingSystem,
    .portableConsole,
    .computer,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_RegionRegionEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case regionRegionNull // = 0
  case europe // = 1
  case northAmerica // = 2
  case australia // = 3
  case newZealand // = 4
  case japan // = 5
  case china // = 6
  case asia // = 7
  case worldwide // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .regionRegionNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .regionRegionNull
    case 1: self = .europe
    case 2: self = .northAmerica
    case 3: self = .australia
    case 4: self = .newZealand
    case 5: self = .japan
    case 6: self = .china
    case 7: self = .asia
    case 8: self = .worldwide
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .regionRegionNull: return 0
    case .europe: return 1
    case .northAmerica: return 2
    case .australia: return 3
    case .newZealand: return 4
    case .japan: return 5
    case .china: return 6
    case .asia: return 7
    case .worldwide: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_RegionRegionEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_RegionRegionEnum] = [
    .regionRegionNull,
    .europe,
    .northAmerica,
    .australia,
    .newZealand,
    .japan,
    .china,
    .asia,
    .worldwide,
  ]
}

#endif  // swift(>=4.2)

public enum Proto_TestDummyEnumTestEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case testdummyEnumTestNull // = 0
  case enum1 // = 1
  case enum2 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .testdummyEnumTestNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .testdummyEnumTestNull
    case 1: self = .enum1
    case 2: self = .enum2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .testdummyEnumTestNull: return 0
    case .enum1: return 1
    case .enum2: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_TestDummyEnumTestEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Proto_TestDummyEnumTestEnum] = [
    .testdummyEnumTestNull,
    .enum1,
    .enum2,
  ]
}

#endif  // swift(>=4.2)

public struct Proto_Count {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiQueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var results: [Data] = []

  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiQueryResultArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: [Proto_MultiQueryResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ageratings: [Proto_AgeRating] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRating {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_AgeRatingCategoryEnum = .ageratingCategoryNull

  public var contentDescriptions: [Proto_AgeRatingContentDescription] = []

  public var rating: Proto_AgeRatingRatingEnum = .ageratingRatingNull

  public var ratingCoverURL: String = String()

  public var synopsis: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingContentDescriptionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ageratingcontentdescriptions: [Proto_AgeRatingContentDescription] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AgeRatingContentDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_AgeRatingRatingEnum = .ageratingRatingNull

  public var description_p: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AlternativeNameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alternativenames: [Proto_AlternativeName] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_AlternativeName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var comment: String = String()

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_ArtworkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artworks: [Proto_Artwork] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Artwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_CharacterResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var characters: [Proto_Character] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Character {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var akas: [String] {
    get {return _storage._akas}
    set {_uniqueStorage()._akas = newValue}
  }

  public var countryName: String {
    get {return _storage._countryName}
    set {_uniqueStorage()._countryName = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var games: [Proto_Game] {
    get {return _storage._games}
    set {_uniqueStorage()._games = newValue}
  }

  public var gender: Proto_GenderGenderEnum {
    get {return _storage._gender}
    set {_uniqueStorage()._gender = newValue}
  }

  public var mugShot: Proto_CharacterMugShot {
    get {return _storage._mugShot ?? Proto_CharacterMugShot()}
    set {_uniqueStorage()._mugShot = newValue}
  }
  /// Returns true if `mugShot` has been explicitly set.
  public var hasMugShot: Bool {return _storage._mugShot != nil}
  /// Clears the value of `mugShot`. Subsequent reads from it will return its default value.
  public mutating func clearMugShot() {_uniqueStorage()._mugShot = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var species: Proto_CharacterSpeciesEnum {
    get {return _storage._species}
    set {_uniqueStorage()._species = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_CharacterMugShotResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charactermugshots: [Proto_CharacterMugShot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CharacterMugShot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CollectionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var collections: [Proto_Collection] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Collection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var games: [Proto_Game] = []

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_CompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companies: [Proto_Company] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Company {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var changeDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._changeDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._changeDate = newValue}
  }
  /// Returns true if `changeDate` has been explicitly set.
  public var hasChangeDate: Bool {return _storage._changeDate != nil}
  /// Clears the value of `changeDate`. Subsequent reads from it will return its default value.
  public mutating func clearChangeDate() {_uniqueStorage()._changeDate = nil}

  public var changeDateCategory: Proto_DateFormatChangeDateCategoryEnum {
    get {return _storage._changeDateCategory}
    set {_uniqueStorage()._changeDateCategory = newValue}
  }

  public var changedCompanyID: Proto_Company {
    get {return _storage._changedCompanyID ?? Proto_Company()}
    set {_uniqueStorage()._changedCompanyID = newValue}
  }
  /// Returns true if `changedCompanyID` has been explicitly set.
  public var hasChangedCompanyID: Bool {return _storage._changedCompanyID != nil}
  /// Clears the value of `changedCompanyID`. Subsequent reads from it will return its default value.
  public mutating func clearChangedCompanyID() {_uniqueStorage()._changedCompanyID = nil}

  public var country: Int32 {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var developed: [Proto_Game] {
    get {return _storage._developed}
    set {_uniqueStorage()._developed = newValue}
  }

  public var logo: Proto_CompanyLogo {
    get {return _storage._logo ?? Proto_CompanyLogo()}
    set {_uniqueStorage()._logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return _storage._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {_uniqueStorage()._logo = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var parent: Proto_Company {
    get {return _storage._parent ?? Proto_Company()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {_uniqueStorage()._parent = nil}

  public var published: [Proto_Game] {
    get {return _storage._published}
    set {_uniqueStorage()._published = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  public var startDateCategory: Proto_DateFormatChangeDateCategoryEnum {
    get {return _storage._startDateCategory}
    set {_uniqueStorage()._startDateCategory = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var websites: [Proto_CompanyWebsite] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_CompanyLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companylogos: [Proto_CompanyLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyWebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companywebsites: [Proto_CompanyWebsite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CompanyWebsite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_CoverResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var covers: [Proto_Cover] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Cover {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var alphaChannel: Bool {
    get {return _storage._alphaChannel}
    set {_uniqueStorage()._alphaChannel = newValue}
  }

  public var animated: Bool {
    get {return _storage._animated}
    set {_uniqueStorage()._animated = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var imageID: String {
    get {return _storage._imageID}
    set {_uniqueStorage()._imageID = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var width: Int32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_ExternalGameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var externalgames: [Proto_ExternalGame] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ExternalGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_ExternalGameCategoryEnum = .externalgameCategoryNull

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var uid: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var year: Int32 = 0

  public var media: Proto_ExternalGameMediaEnum = .externalgameMediaNull

  public var platform: Proto_Platform {
    get {return _platform ?? Proto_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var countries: [Int32] = []

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _platform: Proto_Platform? = nil
}

public struct Proto_FranchiseResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var franchises: [Proto_Franchise] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Franchise {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var games: [Proto_Game] = []

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var games: [Proto_Game] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Game {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var ageRatings: [Proto_AgeRating] {
    get {return _storage._ageRatings}
    set {_uniqueStorage()._ageRatings = newValue}
  }

  public var aggregatedRating: Double {
    get {return _storage._aggregatedRating}
    set {_uniqueStorage()._aggregatedRating = newValue}
  }

  public var aggregatedRatingCount: Int32 {
    get {return _storage._aggregatedRatingCount}
    set {_uniqueStorage()._aggregatedRatingCount = newValue}
  }

  public var alternativeNames: [Proto_AlternativeName] {
    get {return _storage._alternativeNames}
    set {_uniqueStorage()._alternativeNames = newValue}
  }

  public var artworks: [Proto_Artwork] {
    get {return _storage._artworks}
    set {_uniqueStorage()._artworks = newValue}
  }

  public var bundles: [Proto_Game] {
    get {return _storage._bundles}
    set {_uniqueStorage()._bundles = newValue}
  }

  public var category: Proto_GameCategoryEnum {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var collection: Proto_Collection {
    get {return _storage._collection ?? Proto_Collection()}
    set {_uniqueStorage()._collection = newValue}
  }
  /// Returns true if `collection` has been explicitly set.
  public var hasCollection: Bool {return _storage._collection != nil}
  /// Clears the value of `collection`. Subsequent reads from it will return its default value.
  public mutating func clearCollection() {_uniqueStorage()._collection = nil}

  public var cover: Proto_Cover {
    get {return _storage._cover ?? Proto_Cover()}
    set {_uniqueStorage()._cover = newValue}
  }
  /// Returns true if `cover` has been explicitly set.
  public var hasCover: Bool {return _storage._cover != nil}
  /// Clears the value of `cover`. Subsequent reads from it will return its default value.
  public mutating func clearCover() {_uniqueStorage()._cover = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var dlcs: [Proto_Game] {
    get {return _storage._dlcs}
    set {_uniqueStorage()._dlcs = newValue}
  }

  public var expansions: [Proto_Game] {
    get {return _storage._expansions}
    set {_uniqueStorage()._expansions = newValue}
  }

  public var externalGames: [Proto_ExternalGame] {
    get {return _storage._externalGames}
    set {_uniqueStorage()._externalGames = newValue}
  }

  public var firstReleaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstReleaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstReleaseDate = newValue}
  }
  /// Returns true if `firstReleaseDate` has been explicitly set.
  public var hasFirstReleaseDate: Bool {return _storage._firstReleaseDate != nil}
  /// Clears the value of `firstReleaseDate`. Subsequent reads from it will return its default value.
  public mutating func clearFirstReleaseDate() {_uniqueStorage()._firstReleaseDate = nil}

  public var follows: Int32 {
    get {return _storage._follows}
    set {_uniqueStorage()._follows = newValue}
  }

  public var franchise: Proto_Franchise {
    get {return _storage._franchise ?? Proto_Franchise()}
    set {_uniqueStorage()._franchise = newValue}
  }
  /// Returns true if `franchise` has been explicitly set.
  public var hasFranchise: Bool {return _storage._franchise != nil}
  /// Clears the value of `franchise`. Subsequent reads from it will return its default value.
  public mutating func clearFranchise() {_uniqueStorage()._franchise = nil}

  public var franchises: [Proto_Franchise] {
    get {return _storage._franchises}
    set {_uniqueStorage()._franchises = newValue}
  }

  public var gameEngines: [Proto_GameEngine] {
    get {return _storage._gameEngines}
    set {_uniqueStorage()._gameEngines = newValue}
  }

  public var gameModes: [Proto_GameMode] {
    get {return _storage._gameModes}
    set {_uniqueStorage()._gameModes = newValue}
  }

  public var genres: [Proto_Genre] {
    get {return _storage._genres}
    set {_uniqueStorage()._genres = newValue}
  }

  public var hypes: Int32 {
    get {return _storage._hypes}
    set {_uniqueStorage()._hypes = newValue}
  }

  public var involvedCompanies: [Proto_InvolvedCompany] {
    get {return _storage._involvedCompanies}
    set {_uniqueStorage()._involvedCompanies = newValue}
  }

  public var keywords: [Proto_Keyword] {
    get {return _storage._keywords}
    set {_uniqueStorage()._keywords = newValue}
  }

  public var multiplayerModes: [Proto_MultiplayerMode] {
    get {return _storage._multiplayerModes}
    set {_uniqueStorage()._multiplayerModes = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var parentGame: Proto_Game {
    get {return _storage._parentGame ?? Proto_Game()}
    set {_uniqueStorage()._parentGame = newValue}
  }
  /// Returns true if `parentGame` has been explicitly set.
  public var hasParentGame: Bool {return _storage._parentGame != nil}
  /// Clears the value of `parentGame`. Subsequent reads from it will return its default value.
  public mutating func clearParentGame() {_uniqueStorage()._parentGame = nil}

  public var platforms: [Proto_Platform] {
    get {return _storage._platforms}
    set {_uniqueStorage()._platforms = newValue}
  }

  public var playerPerspectives: [Proto_PlayerPerspective] {
    get {return _storage._playerPerspectives}
    set {_uniqueStorage()._playerPerspectives = newValue}
  }

  public var rating: Double {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  public var ratingCount: Int32 {
    get {return _storage._ratingCount}
    set {_uniqueStorage()._ratingCount = newValue}
  }

  public var releaseDates: [Proto_ReleaseDate] {
    get {return _storage._releaseDates}
    set {_uniqueStorage()._releaseDates = newValue}
  }

  public var screenshots: [Proto_Screenshot] {
    get {return _storage._screenshots}
    set {_uniqueStorage()._screenshots = newValue}
  }

  public var similarGames: [Proto_Game] {
    get {return _storage._similarGames}
    set {_uniqueStorage()._similarGames = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var standaloneExpansions: [Proto_Game] {
    get {return _storage._standaloneExpansions}
    set {_uniqueStorage()._standaloneExpansions = newValue}
  }

  public var status: Proto_GameStatusEnum {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var storyline: String {
    get {return _storage._storyline}
    set {_uniqueStorage()._storyline = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var tags: [Int32] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var themes: [Proto_Theme] {
    get {return _storage._themes}
    set {_uniqueStorage()._themes = newValue}
  }

  public var totalRating: Double {
    get {return _storage._totalRating}
    set {_uniqueStorage()._totalRating = newValue}
  }

  public var totalRatingCount: Int32 {
    get {return _storage._totalRatingCount}
    set {_uniqueStorage()._totalRatingCount = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var versionParent: Proto_Game {
    get {return _storage._versionParent ?? Proto_Game()}
    set {_uniqueStorage()._versionParent = newValue}
  }
  /// Returns true if `versionParent` has been explicitly set.
  public var hasVersionParent: Bool {return _storage._versionParent != nil}
  /// Clears the value of `versionParent`. Subsequent reads from it will return its default value.
  public mutating func clearVersionParent() {_uniqueStorage()._versionParent = nil}

  public var versionTitle: String {
    get {return _storage._versionTitle}
    set {_uniqueStorage()._versionTitle = newValue}
  }

  public var videos: [Proto_GameVideo] {
    get {return _storage._videos}
    set {_uniqueStorage()._videos = newValue}
  }

  public var websites: [Proto_Website] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_GameEngineResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameengines: [Proto_GameEngine] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameEngine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var companies: [Proto_Company] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var logo: Proto_GameEngineLogo {
    get {return _storage._logo ?? Proto_GameEngineLogo()}
    set {_uniqueStorage()._logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return _storage._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {_uniqueStorage()._logo = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platforms: [Proto_Platform] {
    get {return _storage._platforms}
    set {_uniqueStorage()._platforms = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_GameEngineLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameenginelogos: [Proto_GameEngineLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameEngineLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameModeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gamemodes: [Proto_GameMode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameVersionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversions: [Proto_GameVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var features: [Proto_GameVersionFeature] = []

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var games: [Proto_Game] = []

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_GameVersionFeatureResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversionfeatures: [Proto_GameVersionFeature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_GameVersionFeatureCategoryEnum = .boolean

  public var description_p: String = String()

  public var position: Int32 = 0

  public var title: String = String()

  public var values: [Proto_GameVersionFeatureValue] = []

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeatureValueResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameversionfeaturevalues: [Proto_GameVersionFeatureValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVersionFeatureValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var gameFeature: Proto_GameVersionFeature {
    get {return _gameFeature ?? Proto_GameVersionFeature()}
    set {_gameFeature = newValue}
  }
  /// Returns true if `gameFeature` has been explicitly set.
  public var hasGameFeature: Bool {return self._gameFeature != nil}
  /// Clears the value of `gameFeature`. Subsequent reads from it will return its default value.
  public mutating func clearGameFeature() {self._gameFeature = nil}

  public var includedFeature: Proto_GameVersionFeatureValueIncludedFeatureEnum = .notIncluded

  public var note: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
  fileprivate var _gameFeature: Proto_GameVersionFeature? = nil
}

public struct Proto_GameVideoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gamevideos: [Proto_GameVideo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_GameVideo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var name: String = String()

  public var videoID: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_GenreResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genres: [Proto_Genre] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Genre {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_InvolvedCompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var involvedcompanies: [Proto_InvolvedCompany] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_InvolvedCompany {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var company: Proto_Company {
    get {return _company ?? Proto_Company()}
    set {_company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return self._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {self._company = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var developer: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var porting: Bool = false

  public var publisher: Bool = false

  public var supporting: Bool = false

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _company: Proto_Company? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_KeywordResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keywords: [Proto_Keyword] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Keyword {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_MultiplayerModeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var multiplayermodes: [Proto_MultiplayerMode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_MultiplayerMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var campaigncoop: Bool = false

  public var dropin: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var lancoop: Bool = false

  public var offlinecoop: Bool = false

  public var offlinecoopmax: Int32 = 0

  public var offlinemax: Int32 = 0

  public var onlinecoop: Bool = false

  public var onlinecoopmax: Int32 = 0

  public var onlinemax: Int32 = 0

  public var platform: Proto_Platform {
    get {return _platform ?? Proto_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var splitscreen: Bool = false

  public var splitscreenonline: Bool = false

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
  fileprivate var _platform: Proto_Platform? = nil
}

public struct Proto_PlatformResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platforms: [Proto_Platform] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Platform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var abbreviation: String {
    get {return _storage._abbreviation}
    set {_uniqueStorage()._abbreviation = newValue}
  }

  public var alternativeName: String {
    get {return _storage._alternativeName}
    set {_uniqueStorage()._alternativeName = newValue}
  }

  public var category: Proto_PlatformCategoryEnum {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var generation: Int32 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platformLogo: Proto_PlatformLogo {
    get {return _storage._platformLogo ?? Proto_PlatformLogo()}
    set {_uniqueStorage()._platformLogo = newValue}
  }
  /// Returns true if `platformLogo` has been explicitly set.
  public var hasPlatformLogo: Bool {return _storage._platformLogo != nil}
  /// Clears the value of `platformLogo`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformLogo() {_uniqueStorage()._platformLogo = nil}

  public var platformFamily: Proto_PlatformFamily {
    get {return _storage._platformFamily ?? Proto_PlatformFamily()}
    set {_uniqueStorage()._platformFamily = newValue}
  }
  /// Returns true if `platformFamily` has been explicitly set.
  public var hasPlatformFamily: Bool {return _storage._platformFamily != nil}
  /// Clears the value of `platformFamily`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformFamily() {_uniqueStorage()._platformFamily = nil}

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var versions: [Proto_PlatformVersion] {
    get {return _storage._versions}
    set {_uniqueStorage()._versions = newValue}
  }

  public var websites: [Proto_PlatformWebsite] {
    get {return _storage._websites}
    set {_uniqueStorage()._websites = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_PlatformFamilyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformfamilies: [Proto_PlatformFamily] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformFamily {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var slug: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformLogoResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformlogos: [Proto_PlatformLogo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformLogo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversions: [Proto_PlatformVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var companies: [Proto_PlatformVersionCompany] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  public var connectivity: String {
    get {return _storage._connectivity}
    set {_uniqueStorage()._connectivity = newValue}
  }

  public var cpu: String {
    get {return _storage._cpu}
    set {_uniqueStorage()._cpu = newValue}
  }

  public var graphics: String {
    get {return _storage._graphics}
    set {_uniqueStorage()._graphics = newValue}
  }

  public var mainManufacturer: Proto_PlatformVersionCompany {
    get {return _storage._mainManufacturer ?? Proto_PlatformVersionCompany()}
    set {_uniqueStorage()._mainManufacturer = newValue}
  }
  /// Returns true if `mainManufacturer` has been explicitly set.
  public var hasMainManufacturer: Bool {return _storage._mainManufacturer != nil}
  /// Clears the value of `mainManufacturer`. Subsequent reads from it will return its default value.
  public mutating func clearMainManufacturer() {_uniqueStorage()._mainManufacturer = nil}

  public var media: String {
    get {return _storage._media}
    set {_uniqueStorage()._media = newValue}
  }

  public var memory: String {
    get {return _storage._memory}
    set {_uniqueStorage()._memory = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var online: String {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  public var os: String {
    get {return _storage._os}
    set {_uniqueStorage()._os = newValue}
  }

  public var output: String {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  public var platformLogo: Proto_PlatformLogo {
    get {return _storage._platformLogo ?? Proto_PlatformLogo()}
    set {_uniqueStorage()._platformLogo = newValue}
  }
  /// Returns true if `platformLogo` has been explicitly set.
  public var hasPlatformLogo: Bool {return _storage._platformLogo != nil}
  /// Clears the value of `platformLogo`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformLogo() {_uniqueStorage()._platformLogo = nil}

  public var platformVersionReleaseDates: [Proto_PlatformVersionReleaseDate] {
    get {return _storage._platformVersionReleaseDates}
    set {_uniqueStorage()._platformVersionReleaseDates = newValue}
  }

  public var resolutions: String {
    get {return _storage._resolutions}
    set {_uniqueStorage()._resolutions = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var sound: String {
    get {return _storage._sound}
    set {_uniqueStorage()._sound = newValue}
  }

  public var storage: String {
    get {return _storage._storage}
    set {_uniqueStorage()._storage = newValue}
  }

  public var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_PlatformVersionCompanyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversioncompanies: [Proto_PlatformVersionCompany] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionCompany {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var comment: String = String()

  public var company: Proto_Company {
    get {return _company ?? Proto_Company()}
    set {_company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return self._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {self._company = nil}

  public var developer: Bool = false

  public var manufacturer: Bool = false

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _company: Proto_Company? = nil
}

public struct Proto_PlatformVersionReleaseDateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformversionreleasedates: [Proto_PlatformVersionReleaseDate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformVersionReleaseDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var human: String = String()

  public var m: Int32 = 0

  public var platformVersion: Proto_PlatformVersion {
    get {return _platformVersion ?? Proto_PlatformVersion()}
    set {_platformVersion = newValue}
  }
  /// Returns true if `platformVersion` has been explicitly set.
  public var hasPlatformVersion: Bool {return self._platformVersion != nil}
  /// Clears the value of `platformVersion`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformVersion() {self._platformVersion = nil}

  public var region: Proto_RegionRegionEnum = .regionRegionNull

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var y: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _platformVersion: Proto_PlatformVersion? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_PlatformWebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var platformwebsites: [Proto_PlatformWebsite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlatformWebsite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlayerPerspectiveResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var playerperspectives: [Proto_PlayerPerspective] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_PlayerPerspective {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_ReleaseDateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var releasedates: [Proto_ReleaseDate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_ReleaseDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var human: String = String()

  public var m: Int32 = 0

  public var platform: Proto_Platform {
    get {return _platform ?? Proto_Platform()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  public var region: Proto_RegionRegionEnum = .regionRegionNull

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var y: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _game: Proto_Game? = nil
  fileprivate var _platform: Proto_Platform? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_ScreenshotResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var screenshots: [Proto_Screenshot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Screenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var alphaChannel: Bool = false

  public var animated: Bool = false

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var height: Int32 = 0

  public var imageID: String = String()

  public var url: String = String()

  public var width: Int32 = 0

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

public struct Proto_SearchResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var searches: [Proto_Search] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Search {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var alternativeName: String {
    get {return _storage._alternativeName}
    set {_uniqueStorage()._alternativeName = newValue}
  }

  public var character: Proto_Character {
    get {return _storage._character ?? Proto_Character()}
    set {_uniqueStorage()._character = newValue}
  }
  /// Returns true if `character` has been explicitly set.
  public var hasCharacter: Bool {return _storage._character != nil}
  /// Clears the value of `character`. Subsequent reads from it will return its default value.
  public mutating func clearCharacter() {_uniqueStorage()._character = nil}

  public var collection: Proto_Collection {
    get {return _storage._collection ?? Proto_Collection()}
    set {_uniqueStorage()._collection = newValue}
  }
  /// Returns true if `collection` has been explicitly set.
  public var hasCollection: Bool {return _storage._collection != nil}
  /// Clears the value of `collection`. Subsequent reads from it will return its default value.
  public mutating func clearCollection() {_uniqueStorage()._collection = nil}

  public var company: Proto_Company {
    get {return _storage._company ?? Proto_Company()}
    set {_uniqueStorage()._company = newValue}
  }
  /// Returns true if `company` has been explicitly set.
  public var hasCompany: Bool {return _storage._company != nil}
  /// Clears the value of `company`. Subsequent reads from it will return its default value.
  public mutating func clearCompany() {_uniqueStorage()._company = nil}

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var platform: Proto_Platform {
    get {return _storage._platform ?? Proto_Platform()}
    set {_uniqueStorage()._platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return _storage._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {_uniqueStorage()._platform = nil}

  public var publishedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._publishedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._publishedAt = newValue}
  }
  /// Returns true if `publishedAt` has been explicitly set.
  public var hasPublishedAt: Bool {return _storage._publishedAt != nil}
  /// Clears the value of `publishedAt`. Subsequent reads from it will return its default value.
  public mutating func clearPublishedAt() {_uniqueStorage()._publishedAt = nil}

  public var testDummy: Proto_TestDummy {
    get {return _storage._testDummy ?? Proto_TestDummy()}
    set {_uniqueStorage()._testDummy = newValue}
  }
  /// Returns true if `testDummy` has been explicitly set.
  public var hasTestDummy: Bool {return _storage._testDummy != nil}
  /// Clears the value of `testDummy`. Subsequent reads from it will return its default value.
  public mutating func clearTestDummy() {_uniqueStorage()._testDummy = nil}

  public var theme: Proto_Theme {
    get {return _storage._theme ?? Proto_Theme()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  public var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  public mutating func clearTheme() {_uniqueStorage()._theme = nil}

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_TestDummyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var testdummies: [Proto_TestDummy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_TestDummy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var boolValue: Bool {
    get {return _storage._boolValue}
    set {_uniqueStorage()._boolValue = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var enumTest: Proto_TestDummyEnumTestEnum {
    get {return _storage._enumTest}
    set {_uniqueStorage()._enumTest = newValue}
  }

  public var floatValue: Double {
    get {return _storage._floatValue}
    set {_uniqueStorage()._floatValue = newValue}
  }

  public var game: Proto_Game {
    get {return _storage._game ?? Proto_Game()}
    set {_uniqueStorage()._game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return _storage._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {_uniqueStorage()._game = nil}

  public var integerArray: [Int32] {
    get {return _storage._integerArray}
    set {_uniqueStorage()._integerArray = newValue}
  }

  public var integerValue: Int32 {
    get {return _storage._integerValue}
    set {_uniqueStorage()._integerValue = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var newIntegerValue: Int32 {
    get {return _storage._newIntegerValue}
    set {_uniqueStorage()._newIntegerValue = newValue}
  }

  public var `private`: Bool {
    get {return _storage._private}
    set {_uniqueStorage()._private = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var stringArray: [String] {
    get {return _storage._stringArray}
    set {_uniqueStorage()._stringArray = newValue}
  }

  public var testDummies: [Proto_TestDummy] {
    get {return _storage._testDummies}
    set {_uniqueStorage()._testDummies = newValue}
  }

  public var testDummy: Proto_TestDummy {
    get {return _storage._testDummy ?? Proto_TestDummy()}
    set {_uniqueStorage()._testDummy = newValue}
  }
  /// Returns true if `testDummy` has been explicitly set.
  public var hasTestDummy: Bool {return _storage._testDummy != nil}
  /// Clears the value of `testDummy`. Subsequent reads from it will return its default value.
  public mutating func clearTestDummy() {_uniqueStorage()._testDummy = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Proto_ThemeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var themes: [Proto_Theme] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Theme {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var name: String = String()

  public var slug: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Proto_WebsiteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var websites: [Proto_Website] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Proto_Website {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var category: Proto_WebsiteCategoryEnum = .websiteCategoryNull

  public var game: Proto_Game {
    get {return _game ?? Proto_Game()}
    set {_game = newValue}
  }
  /// Returns true if `game` has been explicitly set.
  public var hasGame: Bool {return self._game != nil}
  /// Clears the value of `game`. Subsequent reads from it will return its default value.
  public mutating func clearGame() {self._game = nil}

  public var trusted: Bool = false

  public var url: String = String()

  public var checksum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _game: Proto_Game? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_AgeRatingCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGERATING_CATEGORY_NULL"),
    1: .same(proto: "ESRB"),
    2: .same(proto: "PEGI"),
  ]
}

extension Proto_AgeRatingRatingEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGERATING_RATING_NULL"),
    1: .same(proto: "THREE"),
    2: .same(proto: "SEVEN"),
    3: .same(proto: "TWELVE"),
    4: .same(proto: "SIXTEEN"),
    5: .same(proto: "EIGHTEEN"),
    6: .same(proto: "RP"),
    7: .same(proto: "EC"),
    8: .same(proto: "E"),
    9: .same(proto: "E10"),
    10: .same(proto: "T"),
    11: .same(proto: "M"),
    12: .same(proto: "AO"),
  ]
}

extension Proto_GenderGenderEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENDER_GENDER_NULL"),
    1: .same(proto: "MALE"),
    2: .same(proto: "FEMALE"),
    3: .same(proto: "OTHER"),
  ]
}

extension Proto_CharacterSpeciesEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHARACTER_SPECIES_NULL"),
    1: .same(proto: "HUMAN"),
    2: .same(proto: "ALIEN"),
    3: .same(proto: "ANIMAL"),
    4: .same(proto: "ANDROID"),
    5: .same(proto: "UNKNOWN"),
  ]
}

extension Proto_DateFormatChangeDateCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YYYYMMMMDD"),
    1: .same(proto: "YYYYMMMM"),
    2: .same(proto: "YYYY"),
    3: .same(proto: "YYYYQ1"),
    4: .same(proto: "YYYYQ2"),
    5: .same(proto: "YYYYQ3"),
    6: .same(proto: "YYYYQ4"),
    7: .same(proto: "TBD"),
  ]
}

extension Proto_WebsiteCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WEBSITE_CATEGORY_NULL"),
    1: .same(proto: "WEBSITE_OFFICIAL"),
    2: .same(proto: "WEBSITE_WIKIA"),
    3: .same(proto: "WEBSITE_WIKIPEDIA"),
    4: .same(proto: "WEBSITE_FACEBOOK"),
    5: .same(proto: "WEBSITE_TWITTER"),
    6: .same(proto: "WEBSITE_TWITCH"),
    8: .same(proto: "WEBSITE_INSTAGRAM"),
    9: .same(proto: "WEBSITE_YOUTUBE"),
    10: .same(proto: "WEBSITE_IPHONE"),
    11: .same(proto: "WEBSITE_IPAD"),
    12: .same(proto: "WEBSITE_ANDROID"),
    13: .same(proto: "WEBSITE_STEAM"),
    14: .same(proto: "WEBSITE_REDDIT"),
    15: .same(proto: "WEBSITE_ITCH"),
    16: .same(proto: "WEBSITE_EPICGAMES"),
    17: .same(proto: "WEBSITE_GOG"),
    18: .same(proto: "WEBSITE_DISCORD"),
  ]
}

extension Proto_ExternalGameCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNALGAME_CATEGORY_NULL"),
    1: .same(proto: "EXTERNALGAME_STEAM"),
    5: .same(proto: "EXTERNALGAME_GOG"),
    10: .same(proto: "EXTERNALGAME_YOUTUBE"),
    11: .same(proto: "EXTERNALGAME_MICROSOFT"),
    13: .same(proto: "EXTERNALGAME_APPLE"),
    14: .same(proto: "EXTERNALGAME_TWITCH"),
    15: .same(proto: "EXTERNALGAME_ANDROID"),
  ]
}

extension Proto_ExternalGameMediaEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNALGAME_MEDIA_NULL"),
    1: .same(proto: "EXTERNALGAME_DIGITAL"),
    2: .same(proto: "EXTERNALGAME_PHYSICAL"),
  ]
}

extension Proto_GameCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAIN_GAME"),
    1: .same(proto: "DLC_ADDON"),
    2: .same(proto: "EXPANSION"),
    3: .same(proto: "BUNDLE"),
    4: .same(proto: "STANDALONE_EXPANSION"),
    5: .same(proto: "MOD"),
    6: .same(proto: "EPISODE"),
    7: .same(proto: "SEASON"),
  ]
}

extension Proto_GameStatusEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RELEASED"),
    2: .same(proto: "ALPHA"),
    3: .same(proto: "BETA"),
    4: .same(proto: "EARLY_ACCESS"),
    5: .same(proto: "OFFLINE"),
    6: .same(proto: "CANCELLED"),
    7: .same(proto: "RUMORED"),
  ]
}

extension Proto_GameVersionFeatureCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOOLEAN"),
    1: .same(proto: "DESCRIPTION"),
  ]
}

extension Proto_GameVersionFeatureValueIncludedFeatureEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_INCLUDED"),
    1: .same(proto: "INCLUDED"),
    2: .same(proto: "PRE_ORDER_ONLY"),
  ]
}

extension Proto_PlatformCategoryEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_CATEGORY_NULL"),
    1: .same(proto: "CONSOLE"),
    2: .same(proto: "ARCADE"),
    3: .same(proto: "PLATFORM"),
    4: .same(proto: "OPERATING_SYSTEM"),
    5: .same(proto: "PORTABLE_CONSOLE"),
    6: .same(proto: "COMPUTER"),
  ]
}

extension Proto_RegionRegionEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGION_REGION_NULL"),
    1: .same(proto: "EUROPE"),
    2: .same(proto: "NORTH_AMERICA"),
    3: .same(proto: "AUSTRALIA"),
    4: .same(proto: "NEW_ZEALAND"),
    5: .same(proto: "JAPAN"),
    6: .same(proto: "CHINA"),
    7: .same(proto: "ASIA"),
    8: .same(proto: "WORLDWIDE"),
  ]
}

extension Proto_TestDummyEnumTestEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TESTDUMMY_ENUM_TEST_NULL"),
    1: .same(proto: "ENUM1"),
    2: .same(proto: "ENUM2"),
  ]
}

extension Proto_Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Count, rhs: Proto_Count) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiQueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiQueryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "results"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.results) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.results, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiQueryResult, rhs: Proto_MultiQueryResult) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.results != rhs.results {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiQueryResultArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiQueryResultArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiQueryResultArray, rhs: Proto_MultiQueryResultArray) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ageratings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ageratings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ageratings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ageratings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingResult, rhs: Proto_AgeRatingResult) -> Bool {
    if lhs.ageratings != rhs.ageratings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRating: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRating"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "content_descriptions"),
    4: .same(proto: "rating"),
    5: .standard(proto: "rating_cover_url"),
    6: .same(proto: "synopsis"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contentDescriptions) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rating) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ratingCoverURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.synopsis) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .ageratingCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.contentDescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contentDescriptions, fieldNumber: 3)
    }
    if self.rating != .ageratingRatingNull {
      try visitor.visitSingularEnumField(value: self.rating, fieldNumber: 4)
    }
    if !self.ratingCoverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.ratingCoverURL, fieldNumber: 5)
    }
    if !self.synopsis.isEmpty {
      try visitor.visitSingularStringField(value: self.synopsis, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRating, rhs: Proto_AgeRating) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.contentDescriptions != rhs.contentDescriptions {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.ratingCoverURL != rhs.ratingCoverURL {return false}
    if lhs.synopsis != rhs.synopsis {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingContentDescriptionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingContentDescriptionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ageratingcontentdescriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ageratingcontentdescriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ageratingcontentdescriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ageratingcontentdescriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingContentDescriptionResult, rhs: Proto_AgeRatingContentDescriptionResult) -> Bool {
    if lhs.ageratingcontentdescriptions != rhs.ageratingcontentdescriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AgeRatingContentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgeRatingContentDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "description"),
    4: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .ageratingRatingNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AgeRatingContentDescription, rhs: Proto_AgeRatingContentDescription) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AlternativeNameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlternativeNameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alternativenames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alternativenames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alternativenames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alternativenames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AlternativeNameResult, rhs: Proto_AlternativeNameResult) -> Bool {
    if lhs.alternativenames != rhs.alternativenames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AlternativeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlternativeName"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "comment"),
    3: .same(proto: "game"),
    4: .same(proto: "name"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AlternativeName, rhs: Proto_AlternativeName) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ArtworkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArtworkResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artworks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artworks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artworks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artworks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ArtworkResult, rhs: Proto_ArtworkResult) -> Bool {
    if lhs.artworks != rhs.artworks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Artwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Artwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 8)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Artwork, rhs: Proto_Artwork) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs._game != rhs._game {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.characters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.characters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterResult, rhs: Proto_CharacterResult) -> Bool {
    if lhs.characters != rhs.characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Character: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Character"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "akas"),
    3: .standard(proto: "country_name"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "description"),
    6: .same(proto: "games"),
    7: .same(proto: "gender"),
    8: .standard(proto: "mug_shot"),
    9: .same(proto: "name"),
    10: .same(proto: "slug"),
    11: .same(proto: "species"),
    12: .standard(proto: "updated_at"),
    13: .same(proto: "url"),
    14: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _akas: [String] = []
    var _countryName: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _games: [Proto_Game] = []
    var _gender: Proto_GenderGenderEnum = .genderGenderNull
    var _mugShot: Proto_CharacterMugShot? = nil
    var _name: String = String()
    var _slug: String = String()
    var _species: Proto_CharacterSpeciesEnum = .characterSpeciesNull
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _akas = source._akas
      _countryName = source._countryName
      _createdAt = source._createdAt
      _description_p = source._description_p
      _games = source._games
      _gender = source._gender
      _mugShot = source._mugShot
      _name = source._name
      _slug = source._slug
      _species = source._species
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._akas) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._countryName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._games) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._mugShot) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._species) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._akas.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._akas, fieldNumber: 2)
      }
      if !_storage._countryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryName, fieldNumber: 3)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._games.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._games, fieldNumber: 6)
      }
      if _storage._gender != .genderGenderNull {
        try visitor.visitSingularEnumField(value: _storage._gender, fieldNumber: 7)
      }
      if let v = _storage._mugShot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 10)
      }
      if _storage._species != .characterSpeciesNull {
        try visitor.visitSingularEnumField(value: _storage._species, fieldNumber: 11)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 13)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Character, rhs: Proto_Character) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._akas != rhs_storage._akas {return false}
        if _storage._countryName != rhs_storage._countryName {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._games != rhs_storage._games {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._mugShot != rhs_storage._mugShot {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._species != rhs_storage._species {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterMugShotResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterMugShotResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "charactermugshots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.charactermugshots) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.charactermugshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.charactermugshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterMugShotResult, rhs: Proto_CharacterMugShotResult) -> Bool {
    if lhs.charactermugshots != rhs.charactermugshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CharacterMugShot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterMugShot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CharacterMugShot, rhs: Proto_CharacterMugShot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CollectionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collections"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CollectionResult, rhs: Proto_CollectionResult) -> Bool {
    if lhs.collections != rhs.collections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "games"),
    4: .same(proto: "name"),
    5: .same(proto: "slug"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 5)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Collection, rhs: Proto_Collection) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.games != rhs.games {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyResult, rhs: Proto_CompanyResult) -> Bool {
    if lhs.companies != rhs.companies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Company: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Company"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "change_date"),
    3: .standard(proto: "change_date_category"),
    4: .standard(proto: "changed_company_id"),
    5: .same(proto: "country"),
    6: .standard(proto: "created_at"),
    7: .same(proto: "description"),
    8: .same(proto: "developed"),
    9: .same(proto: "logo"),
    10: .same(proto: "name"),
    11: .same(proto: "parent"),
    12: .same(proto: "published"),
    13: .same(proto: "slug"),
    14: .standard(proto: "start_date"),
    15: .standard(proto: "start_date_category"),
    16: .standard(proto: "updated_at"),
    17: .same(proto: "url"),
    18: .same(proto: "websites"),
    19: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _changeDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _changeDateCategory: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd
    var _changedCompanyID: Proto_Company? = nil
    var _country: Int32 = 0
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _developed: [Proto_Game] = []
    var _logo: Proto_CompanyLogo? = nil
    var _name: String = String()
    var _parent: Proto_Company? = nil
    var _published: [Proto_Game] = []
    var _slug: String = String()
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startDateCategory: Proto_DateFormatChangeDateCategoryEnum = .yyyymmmmdd
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _websites: [Proto_CompanyWebsite] = []
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _changeDate = source._changeDate
      _changeDateCategory = source._changeDateCategory
      _changedCompanyID = source._changedCompanyID
      _country = source._country
      _createdAt = source._createdAt
      _description_p = source._description_p
      _developed = source._developed
      _logo = source._logo
      _name = source._name
      _parent = source._parent
      _published = source._published
      _slug = source._slug
      _startDate = source._startDate
      _startDateCategory = source._startDateCategory
      _updatedAt = source._updatedAt
      _url = source._url
      _websites = source._websites
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._changeDate) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._changeDateCategory) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._changedCompanyID) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._country) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._developed) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._logo) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._published) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._startDateCategory) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._changeDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._changeDateCategory != .yyyymmmmdd {
        try visitor.visitSingularEnumField(value: _storage._changeDateCategory, fieldNumber: 3)
      }
      if let v = _storage._changedCompanyID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._country != 0 {
        try visitor.visitSingularInt32Field(value: _storage._country, fieldNumber: 5)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if !_storage._developed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._developed, fieldNumber: 8)
      }
      if let v = _storage._logo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 10)
      }
      if let v = _storage._parent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._published.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._published, fieldNumber: 12)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 13)
      }
      if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._startDateCategory != .yyyymmmmdd {
        try visitor.visitSingularEnumField(value: _storage._startDateCategory, fieldNumber: 15)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 17)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 18)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Company, rhs: Proto_Company) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._changeDate != rhs_storage._changeDate {return false}
        if _storage._changeDateCategory != rhs_storage._changeDateCategory {return false}
        if _storage._changedCompanyID != rhs_storage._changedCompanyID {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._developed != rhs_storage._developed {return false}
        if _storage._logo != rhs_storage._logo {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._published != rhs_storage._published {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._startDateCategory != rhs_storage._startDateCategory {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companylogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companylogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companylogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companylogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyLogoResult, rhs: Proto_CompanyLogoResult) -> Bool {
    if lhs.companylogos != rhs.companylogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyLogo, rhs: Proto_CompanyLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyWebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyWebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companywebsites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.companywebsites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companywebsites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.companywebsites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyWebsiteResult, rhs: Proto_CompanyWebsiteResult) -> Bool {
    if lhs.companywebsites != rhs.companywebsites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompanyWebsite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyWebsite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "trusted"),
    4: .same(proto: "url"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CompanyWebsite, rhs: Proto_CompanyWebsite) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CoverResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoverResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "covers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.covers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.covers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.covers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CoverResult, rhs: Proto_CoverResult) -> Bool {
    if lhs.covers != rhs.covers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Cover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cover"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _alphaChannel: Bool = false
    var _animated: Bool = false
    var _game: Proto_Game? = nil
    var _height: Int32 = 0
    var _imageID: String = String()
    var _url: String = String()
    var _width: Int32 = 0
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _alphaChannel = source._alphaChannel
      _animated = source._animated
      _game = source._game
      _height = source._height
      _imageID = source._imageID
      _url = source._url
      _width = source._width
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._alphaChannel) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._animated) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._imageID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._width) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._alphaChannel != false {
        try visitor.visitSingularBoolField(value: _storage._alphaChannel, fieldNumber: 2)
      }
      if _storage._animated != false {
        try visitor.visitSingularBoolField(value: _storage._animated, fieldNumber: 3)
      }
      if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 5)
      }
      if !_storage._imageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._imageID, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 8)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Cover, rhs: Proto_Cover) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._alphaChannel != rhs_storage._alphaChannel {return false}
        if _storage._animated != rhs_storage._animated {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._imageID != rhs_storage._imageID {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExternalGameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalGameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "externalgames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.externalgames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalgames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalgames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ExternalGameResult, rhs: Proto_ExternalGameResult) -> Bool {
    if lhs.externalgames != rhs.externalgames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExternalGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "game"),
    5: .same(proto: "name"),
    6: .same(proto: "uid"),
    7: .standard(proto: "updated_at"),
    8: .same(proto: "url"),
    9: .same(proto: "year"),
    10: .same(proto: "media"),
    11: .same(proto: "platform"),
    12: .same(proto: "countries"),
    13: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.media) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.countries) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .externalgameCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 6)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 8)
    }
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 9)
    }
    if self.media != .externalgameMediaNull {
      try visitor.visitSingularEnumField(value: self.media, fieldNumber: 10)
    }
    if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if !self.countries.isEmpty {
      try visitor.visitPackedInt32Field(value: self.countries, fieldNumber: 12)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ExternalGame, rhs: Proto_ExternalGame) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.year != rhs.year {return false}
    if lhs.media != rhs.media {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.countries != rhs.countries {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FranchiseResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FranchiseResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "franchises"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.franchises) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.franchises.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.franchises, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FranchiseResult, rhs: Proto_FranchiseResult) -> Bool {
    if lhs.franchises != rhs.franchises {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Franchise: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Franchise"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "games"),
    4: .same(proto: "name"),
    5: .same(proto: "slug"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 5)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Franchise, rhs: Proto_Franchise) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.games != rhs.games {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "games"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameResult, rhs: Proto_GameResult) -> Bool {
    if lhs.games != rhs.games {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Game: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Game"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "age_ratings"),
    3: .standard(proto: "aggregated_rating"),
    4: .standard(proto: "aggregated_rating_count"),
    5: .standard(proto: "alternative_names"),
    6: .same(proto: "artworks"),
    7: .same(proto: "bundles"),
    8: .same(proto: "category"),
    9: .same(proto: "collection"),
    10: .same(proto: "cover"),
    11: .standard(proto: "created_at"),
    12: .same(proto: "dlcs"),
    13: .same(proto: "expansions"),
    14: .standard(proto: "external_games"),
    15: .standard(proto: "first_release_date"),
    16: .same(proto: "follows"),
    17: .same(proto: "franchise"),
    18: .same(proto: "franchises"),
    19: .standard(proto: "game_engines"),
    20: .standard(proto: "game_modes"),
    21: .same(proto: "genres"),
    22: .same(proto: "hypes"),
    23: .standard(proto: "involved_companies"),
    24: .same(proto: "keywords"),
    25: .standard(proto: "multiplayer_modes"),
    26: .same(proto: "name"),
    27: .standard(proto: "parent_game"),
    28: .same(proto: "platforms"),
    29: .standard(proto: "player_perspectives"),
    30: .same(proto: "rating"),
    31: .standard(proto: "rating_count"),
    32: .standard(proto: "release_dates"),
    33: .same(proto: "screenshots"),
    34: .standard(proto: "similar_games"),
    35: .same(proto: "slug"),
    36: .standard(proto: "standalone_expansions"),
    37: .same(proto: "status"),
    38: .same(proto: "storyline"),
    39: .same(proto: "summary"),
    40: .same(proto: "tags"),
    41: .same(proto: "themes"),
    42: .standard(proto: "total_rating"),
    43: .standard(proto: "total_rating_count"),
    44: .standard(proto: "updated_at"),
    45: .same(proto: "url"),
    46: .standard(proto: "version_parent"),
    47: .standard(proto: "version_title"),
    48: .same(proto: "videos"),
    49: .same(proto: "websites"),
    50: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _ageRatings: [Proto_AgeRating] = []
    var _aggregatedRating: Double = 0
    var _aggregatedRatingCount: Int32 = 0
    var _alternativeNames: [Proto_AlternativeName] = []
    var _artworks: [Proto_Artwork] = []
    var _bundles: [Proto_Game] = []
    var _category: Proto_GameCategoryEnum = .mainGame
    var _collection: Proto_Collection? = nil
    var _cover: Proto_Cover? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _dlcs: [Proto_Game] = []
    var _expansions: [Proto_Game] = []
    var _externalGames: [Proto_ExternalGame] = []
    var _firstReleaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _follows: Int32 = 0
    var _franchise: Proto_Franchise? = nil
    var _franchises: [Proto_Franchise] = []
    var _gameEngines: [Proto_GameEngine] = []
    var _gameModes: [Proto_GameMode] = []
    var _genres: [Proto_Genre] = []
    var _hypes: Int32 = 0
    var _involvedCompanies: [Proto_InvolvedCompany] = []
    var _keywords: [Proto_Keyword] = []
    var _multiplayerModes: [Proto_MultiplayerMode] = []
    var _name: String = String()
    var _parentGame: Proto_Game? = nil
    var _platforms: [Proto_Platform] = []
    var _playerPerspectives: [Proto_PlayerPerspective] = []
    var _rating: Double = 0
    var _ratingCount: Int32 = 0
    var _releaseDates: [Proto_ReleaseDate] = []
    var _screenshots: [Proto_Screenshot] = []
    var _similarGames: [Proto_Game] = []
    var _slug: String = String()
    var _standaloneExpansions: [Proto_Game] = []
    var _status: Proto_GameStatusEnum = .released
    var _storyline: String = String()
    var _summary: String = String()
    var _tags: [Int32] = []
    var _themes: [Proto_Theme] = []
    var _totalRating: Double = 0
    var _totalRatingCount: Int32 = 0
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _versionParent: Proto_Game? = nil
    var _versionTitle: String = String()
    var _videos: [Proto_GameVideo] = []
    var _websites: [Proto_Website] = []
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _ageRatings = source._ageRatings
      _aggregatedRating = source._aggregatedRating
      _aggregatedRatingCount = source._aggregatedRatingCount
      _alternativeNames = source._alternativeNames
      _artworks = source._artworks
      _bundles = source._bundles
      _category = source._category
      _collection = source._collection
      _cover = source._cover
      _createdAt = source._createdAt
      _dlcs = source._dlcs
      _expansions = source._expansions
      _externalGames = source._externalGames
      _firstReleaseDate = source._firstReleaseDate
      _follows = source._follows
      _franchise = source._franchise
      _franchises = source._franchises
      _gameEngines = source._gameEngines
      _gameModes = source._gameModes
      _genres = source._genres
      _hypes = source._hypes
      _involvedCompanies = source._involvedCompanies
      _keywords = source._keywords
      _multiplayerModes = source._multiplayerModes
      _name = source._name
      _parentGame = source._parentGame
      _platforms = source._platforms
      _playerPerspectives = source._playerPerspectives
      _rating = source._rating
      _ratingCount = source._ratingCount
      _releaseDates = source._releaseDates
      _screenshots = source._screenshots
      _similarGames = source._similarGames
      _slug = source._slug
      _standaloneExpansions = source._standaloneExpansions
      _status = source._status
      _storyline = source._storyline
      _summary = source._summary
      _tags = source._tags
      _themes = source._themes
      _totalRating = source._totalRating
      _totalRatingCount = source._totalRatingCount
      _updatedAt = source._updatedAt
      _url = source._url
      _versionParent = source._versionParent
      _versionTitle = source._versionTitle
      _videos = source._videos
      _websites = source._websites
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._ageRatings) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._aggregatedRating) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._aggregatedRatingCount) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._alternativeNames) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._artworks) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._bundles) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._collection) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._cover) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._dlcs) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._expansions) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._externalGames) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._firstReleaseDate) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._follows) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._franchise) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._franchises) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._gameEngines) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._gameModes) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._genres) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._hypes) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._involvedCompanies) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._keywords) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._multiplayerModes) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._parentGame) }()
        case 28: try { try decoder.decodeRepeatedMessageField(value: &_storage._platforms) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._playerPerspectives) }()
        case 30: try { try decoder.decodeSingularDoubleField(value: &_storage._rating) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._ratingCount) }()
        case 32: try { try decoder.decodeRepeatedMessageField(value: &_storage._releaseDates) }()
        case 33: try { try decoder.decodeRepeatedMessageField(value: &_storage._screenshots) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._similarGames) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 36: try { try decoder.decodeRepeatedMessageField(value: &_storage._standaloneExpansions) }()
        case 37: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._storyline) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 40: try { try decoder.decodeRepeatedInt32Field(value: &_storage._tags) }()
        case 41: try { try decoder.decodeRepeatedMessageField(value: &_storage._themes) }()
        case 42: try { try decoder.decodeSingularDoubleField(value: &_storage._totalRating) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._totalRatingCount) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._versionParent) }()
        case 47: try { try decoder.decodeSingularStringField(value: &_storage._versionTitle) }()
        case 48: try { try decoder.decodeRepeatedMessageField(value: &_storage._videos) }()
        case 49: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 50: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._ageRatings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ageRatings, fieldNumber: 2)
      }
      if _storage._aggregatedRating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._aggregatedRating, fieldNumber: 3)
      }
      if _storage._aggregatedRatingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._aggregatedRatingCount, fieldNumber: 4)
      }
      if !_storage._alternativeNames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._alternativeNames, fieldNumber: 5)
      }
      if !_storage._artworks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._artworks, fieldNumber: 6)
      }
      if !_storage._bundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bundles, fieldNumber: 7)
      }
      if _storage._category != .mainGame {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 8)
      }
      if let v = _storage._collection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._cover {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._dlcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dlcs, fieldNumber: 12)
      }
      if !_storage._expansions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expansions, fieldNumber: 13)
      }
      if !_storage._externalGames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._externalGames, fieldNumber: 14)
      }
      if let v = _storage._firstReleaseDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._follows != 0 {
        try visitor.visitSingularInt32Field(value: _storage._follows, fieldNumber: 16)
      }
      if let v = _storage._franchise {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._franchises.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._franchises, fieldNumber: 18)
      }
      if !_storage._gameEngines.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameEngines, fieldNumber: 19)
      }
      if !_storage._gameModes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameModes, fieldNumber: 20)
      }
      if !_storage._genres.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._genres, fieldNumber: 21)
      }
      if _storage._hypes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._hypes, fieldNumber: 22)
      }
      if !_storage._involvedCompanies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._involvedCompanies, fieldNumber: 23)
      }
      if !_storage._keywords.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keywords, fieldNumber: 24)
      }
      if !_storage._multiplayerModes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._multiplayerModes, fieldNumber: 25)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 26)
      }
      if let v = _storage._parentGame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if !_storage._platforms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platforms, fieldNumber: 28)
      }
      if !_storage._playerPerspectives.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerPerspectives, fieldNumber: 29)
      }
      if _storage._rating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rating, fieldNumber: 30)
      }
      if _storage._ratingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ratingCount, fieldNumber: 31)
      }
      if !_storage._releaseDates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._releaseDates, fieldNumber: 32)
      }
      if !_storage._screenshots.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._screenshots, fieldNumber: 33)
      }
      if !_storage._similarGames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._similarGames, fieldNumber: 34)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 35)
      }
      if !_storage._standaloneExpansions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._standaloneExpansions, fieldNumber: 36)
      }
      if _storage._status != .released {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 37)
      }
      if !_storage._storyline.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storyline, fieldNumber: 38)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 39)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._tags, fieldNumber: 40)
      }
      if !_storage._themes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._themes, fieldNumber: 41)
      }
      if _storage._totalRating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalRating, fieldNumber: 42)
      }
      if _storage._totalRatingCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalRatingCount, fieldNumber: 43)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 45)
      }
      if let v = _storage._versionParent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }
      if !_storage._versionTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionTitle, fieldNumber: 47)
      }
      if !_storage._videos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._videos, fieldNumber: 48)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 49)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Game, rhs: Proto_Game) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._ageRatings != rhs_storage._ageRatings {return false}
        if _storage._aggregatedRating != rhs_storage._aggregatedRating {return false}
        if _storage._aggregatedRatingCount != rhs_storage._aggregatedRatingCount {return false}
        if _storage._alternativeNames != rhs_storage._alternativeNames {return false}
        if _storage._artworks != rhs_storage._artworks {return false}
        if _storage._bundles != rhs_storage._bundles {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._cover != rhs_storage._cover {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._dlcs != rhs_storage._dlcs {return false}
        if _storage._expansions != rhs_storage._expansions {return false}
        if _storage._externalGames != rhs_storage._externalGames {return false}
        if _storage._firstReleaseDate != rhs_storage._firstReleaseDate {return false}
        if _storage._follows != rhs_storage._follows {return false}
        if _storage._franchise != rhs_storage._franchise {return false}
        if _storage._franchises != rhs_storage._franchises {return false}
        if _storage._gameEngines != rhs_storage._gameEngines {return false}
        if _storage._gameModes != rhs_storage._gameModes {return false}
        if _storage._genres != rhs_storage._genres {return false}
        if _storage._hypes != rhs_storage._hypes {return false}
        if _storage._involvedCompanies != rhs_storage._involvedCompanies {return false}
        if _storage._keywords != rhs_storage._keywords {return false}
        if _storage._multiplayerModes != rhs_storage._multiplayerModes {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._parentGame != rhs_storage._parentGame {return false}
        if _storage._platforms != rhs_storage._platforms {return false}
        if _storage._playerPerspectives != rhs_storage._playerPerspectives {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._ratingCount != rhs_storage._ratingCount {return false}
        if _storage._releaseDates != rhs_storage._releaseDates {return false}
        if _storage._screenshots != rhs_storage._screenshots {return false}
        if _storage._similarGames != rhs_storage._similarGames {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._standaloneExpansions != rhs_storage._standaloneExpansions {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._storyline != rhs_storage._storyline {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._themes != rhs_storage._themes {return false}
        if _storage._totalRating != rhs_storage._totalRating {return false}
        if _storage._totalRatingCount != rhs_storage._totalRatingCount {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._versionParent != rhs_storage._versionParent {return false}
        if _storage._versionTitle != rhs_storage._versionTitle {return false}
        if _storage._videos != rhs_storage._videos {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameengines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameengines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameengines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameengines, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineResult, rhs: Proto_GameEngineResult) -> Bool {
    if lhs.gameengines != rhs.gameengines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "companies"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "description"),
    5: .same(proto: "logo"),
    6: .same(proto: "name"),
    7: .same(proto: "platforms"),
    8: .same(proto: "slug"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "url"),
    11: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _companies: [Proto_Company] = []
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _description_p: String = String()
    var _logo: Proto_GameEngineLogo? = nil
    var _name: String = String()
    var _platforms: [Proto_Platform] = []
    var _slug: String = String()
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _companies = source._companies
      _createdAt = source._createdAt
      _description_p = source._description_p
      _logo = source._logo
      _name = source._name
      _platforms = source._platforms
      _slug = source._slug
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._logo) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._platforms) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._companies, fieldNumber: 2)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if let v = _storage._logo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 6)
      }
      if !_storage._platforms.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platforms, fieldNumber: 7)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 8)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 10)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngine, rhs: Proto_GameEngine) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._logo != rhs_storage._logo {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platforms != rhs_storage._platforms {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameenginelogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameenginelogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameenginelogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameenginelogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineLogoResult, rhs: Proto_GameEngineLogoResult) -> Bool {
    if lhs.gameenginelogos != rhs.gameenginelogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameEngineLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameEngineLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameEngineLogo, rhs: Proto_GameEngineLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameModeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameModeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamemodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gamemodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gamemodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gamemodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameModeResult, rhs: Proto_GameModeResult) -> Bool {
    if lhs.gamemodes != rhs.gamemodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameMode, rhs: Proto_GameMode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionResult, rhs: Proto_GameVersionResult) -> Bool {
    if lhs.gameversions != rhs.gameversions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "features"),
    4: .same(proto: "game"),
    5: .same(proto: "games"),
    6: .standard(proto: "updated_at"),
    7: .same(proto: "url"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.features) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.games) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 3)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.games.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.games, fieldNumber: 5)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersion, rhs: Proto_GameVersion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.features != rhs.features {return false}
    if lhs._game != rhs._game {return false}
    if lhs.games != rhs.games {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversionfeatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversionfeatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversionfeatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversionfeatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureResult, rhs: Proto_GameVersionFeatureResult) -> Bool {
    if lhs.gameversionfeatures != rhs.gameversionfeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "description"),
    4: .same(proto: "position"),
    5: .same(proto: "title"),
    6: .same(proto: "values"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .boolean {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeature, rhs: Proto_GameVersionFeature) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.position != rhs.position {return false}
    if lhs.title != rhs.title {return false}
    if lhs.values != rhs.values {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureValueResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureValueResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameversionfeaturevalues"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameversionfeaturevalues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameversionfeaturevalues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameversionfeaturevalues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureValueResult, rhs: Proto_GameVersionFeatureValueResult) -> Bool {
    if lhs.gameversionfeaturevalues != rhs.gameversionfeaturevalues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVersionFeatureValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVersionFeatureValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "game"),
    3: .standard(proto: "game_feature"),
    4: .standard(proto: "included_feature"),
    5: .same(proto: "note"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gameFeature) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.includedFeature) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.note) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._gameFeature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.includedFeature != .notIncluded {
      try visitor.visitSingularEnumField(value: self.includedFeature, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVersionFeatureValue, rhs: Proto_GameVersionFeatureValue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._game != rhs._game {return false}
    if lhs._gameFeature != rhs._gameFeature {return false}
    if lhs.includedFeature != rhs.includedFeature {return false}
    if lhs.note != rhs.note {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVideoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVideoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamevideos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gamevideos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gamevideos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gamevideos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVideoResult, rhs: Proto_GameVideoResult) -> Bool {
    if lhs.gamevideos != rhs.gamevideos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GameVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "game"),
    3: .same(proto: "name"),
    4: .standard(proto: "video_id"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.videoID.isEmpty {
      try visitor.visitSingularStringField(value: self.videoID, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GameVideo, rhs: Proto_GameVideo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._game != rhs._game {return false}
    if lhs.name != rhs.name {return false}
    if lhs.videoID != rhs.videoID {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GenreResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenreResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "genres"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.genres) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.genres.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.genres, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GenreResult, rhs: Proto_GenreResult) -> Bool {
    if lhs.genres != rhs.genres {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Genre: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Genre"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Genre, rhs: Proto_Genre) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InvolvedCompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvolvedCompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "involvedcompanies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.involvedcompanies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.involvedcompanies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.involvedcompanies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_InvolvedCompanyResult, rhs: Proto_InvolvedCompanyResult) -> Bool {
    if lhs.involvedcompanies != rhs.involvedcompanies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InvolvedCompany: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvolvedCompany"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "company"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "developer"),
    5: .same(proto: "game"),
    6: .same(proto: "porting"),
    7: .same(proto: "publisher"),
    8: .same(proto: "supporting"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._company) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.developer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.porting) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.publisher) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supporting) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._company {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.developer != false {
      try visitor.visitSingularBoolField(value: self.developer, fieldNumber: 4)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.porting != false {
      try visitor.visitSingularBoolField(value: self.porting, fieldNumber: 6)
    }
    if self.publisher != false {
      try visitor.visitSingularBoolField(value: self.publisher, fieldNumber: 7)
    }
    if self.supporting != false {
      try visitor.visitSingularBoolField(value: self.supporting, fieldNumber: 8)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_InvolvedCompany, rhs: Proto_InvolvedCompany) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._company != rhs._company {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.developer != rhs.developer {return false}
    if lhs._game != rhs._game {return false}
    if lhs.porting != rhs.porting {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.supporting != rhs.supporting {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeywordResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeywordResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keywords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keywords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keywords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keywords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_KeywordResult, rhs: Proto_KeywordResult) -> Bool {
    if lhs.keywords != rhs.keywords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Keyword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Keyword"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Keyword, rhs: Proto_Keyword) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiplayerModeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplayerModeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "multiplayermodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.multiplayermodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.multiplayermodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.multiplayermodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiplayerModeResult, rhs: Proto_MultiplayerModeResult) -> Bool {
    if lhs.multiplayermodes != rhs.multiplayermodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MultiplayerMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiplayerMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "campaigncoop"),
    3: .same(proto: "dropin"),
    4: .same(proto: "game"),
    5: .same(proto: "lancoop"),
    6: .same(proto: "offlinecoop"),
    7: .same(proto: "offlinecoopmax"),
    8: .same(proto: "offlinemax"),
    9: .same(proto: "onlinecoop"),
    10: .same(proto: "onlinecoopmax"),
    11: .same(proto: "onlinemax"),
    12: .same(proto: "platform"),
    13: .same(proto: "splitscreen"),
    14: .same(proto: "splitscreenonline"),
    15: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.campaigncoop) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.dropin) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lancoop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.offlinecoop) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.offlinecoopmax) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.offlinemax) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.onlinecoop) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.onlinecoopmax) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.onlinemax) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.splitscreen) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.splitscreenonline) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.campaigncoop != false {
      try visitor.visitSingularBoolField(value: self.campaigncoop, fieldNumber: 2)
    }
    if self.dropin != false {
      try visitor.visitSingularBoolField(value: self.dropin, fieldNumber: 3)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.lancoop != false {
      try visitor.visitSingularBoolField(value: self.lancoop, fieldNumber: 5)
    }
    if self.offlinecoop != false {
      try visitor.visitSingularBoolField(value: self.offlinecoop, fieldNumber: 6)
    }
    if self.offlinecoopmax != 0 {
      try visitor.visitSingularInt32Field(value: self.offlinecoopmax, fieldNumber: 7)
    }
    if self.offlinemax != 0 {
      try visitor.visitSingularInt32Field(value: self.offlinemax, fieldNumber: 8)
    }
    if self.onlinecoop != false {
      try visitor.visitSingularBoolField(value: self.onlinecoop, fieldNumber: 9)
    }
    if self.onlinecoopmax != 0 {
      try visitor.visitSingularInt32Field(value: self.onlinecoopmax, fieldNumber: 10)
    }
    if self.onlinemax != 0 {
      try visitor.visitSingularInt32Field(value: self.onlinemax, fieldNumber: 11)
    }
    if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    if self.splitscreen != false {
      try visitor.visitSingularBoolField(value: self.splitscreen, fieldNumber: 13)
    }
    if self.splitscreenonline != false {
      try visitor.visitSingularBoolField(value: self.splitscreenonline, fieldNumber: 14)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_MultiplayerMode, rhs: Proto_MultiplayerMode) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.campaigncoop != rhs.campaigncoop {return false}
    if lhs.dropin != rhs.dropin {return false}
    if lhs._game != rhs._game {return false}
    if lhs.lancoop != rhs.lancoop {return false}
    if lhs.offlinecoop != rhs.offlinecoop {return false}
    if lhs.offlinecoopmax != rhs.offlinecoopmax {return false}
    if lhs.offlinemax != rhs.offlinemax {return false}
    if lhs.onlinecoop != rhs.onlinecoop {return false}
    if lhs.onlinecoopmax != rhs.onlinecoopmax {return false}
    if lhs.onlinemax != rhs.onlinemax {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.splitscreen != rhs.splitscreen {return false}
    if lhs.splitscreenonline != rhs.splitscreenonline {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platforms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platforms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platforms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platforms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformResult, rhs: Proto_PlatformResult) -> Bool {
    if lhs.platforms != rhs.platforms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "abbreviation"),
    3: .standard(proto: "alternative_name"),
    4: .same(proto: "category"),
    5: .standard(proto: "created_at"),
    6: .same(proto: "generation"),
    7: .same(proto: "name"),
    8: .standard(proto: "platform_logo"),
    9: .standard(proto: "platform_family"),
    10: .same(proto: "slug"),
    11: .same(proto: "summary"),
    12: .standard(proto: "updated_at"),
    13: .same(proto: "url"),
    14: .same(proto: "versions"),
    15: .same(proto: "websites"),
    16: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _abbreviation: String = String()
    var _alternativeName: String = String()
    var _category: Proto_PlatformCategoryEnum = .platformCategoryNull
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _generation: Int32 = 0
    var _name: String = String()
    var _platformLogo: Proto_PlatformLogo? = nil
    var _platformFamily: Proto_PlatformFamily? = nil
    var _slug: String = String()
    var _summary: String = String()
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _versions: [Proto_PlatformVersion] = []
    var _websites: [Proto_PlatformWebsite] = []
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _abbreviation = source._abbreviation
      _alternativeName = source._alternativeName
      _category = source._category
      _createdAt = source._createdAt
      _generation = source._generation
      _name = source._name
      _platformLogo = source._platformLogo
      _platformFamily = source._platformFamily
      _slug = source._slug
      _summary = source._summary
      _updatedAt = source._updatedAt
      _url = source._url
      _versions = source._versions
      _websites = source._websites
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._abbreviation) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._alternativeName) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._generation) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._platformLogo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._platformFamily) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._versions) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._websites) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._abbreviation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._abbreviation, fieldNumber: 2)
      }
      if !_storage._alternativeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alternativeName, fieldNumber: 3)
      }
      if _storage._category != .platformCategoryNull {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 4)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._generation != 0 {
        try visitor.visitSingularInt32Field(value: _storage._generation, fieldNumber: 6)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 7)
      }
      if let v = _storage._platformLogo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._platformFamily {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 10)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 11)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 13)
      }
      if !_storage._versions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versions, fieldNumber: 14)
      }
      if !_storage._websites.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._websites, fieldNumber: 15)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Platform, rhs: Proto_Platform) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._abbreviation != rhs_storage._abbreviation {return false}
        if _storage._alternativeName != rhs_storage._alternativeName {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platformLogo != rhs_storage._platformLogo {return false}
        if _storage._platformFamily != rhs_storage._platformFamily {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._versions != rhs_storage._versions {return false}
        if _storage._websites != rhs_storage._websites {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformFamilyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformFamilyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformfamilies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformfamilies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformfamilies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformfamilies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformFamilyResult, rhs: Proto_PlatformFamilyResult) -> Bool {
    if lhs.platformfamilies != rhs.platformfamilies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformFamily"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "slug"),
    4: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 3)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformFamily, rhs: Proto_PlatformFamily) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformLogoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformLogoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformlogos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformlogos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformlogos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformlogos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformLogoResult, rhs: Proto_PlatformLogoResult) -> Bool {
    if lhs.platformlogos != rhs.platformlogos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformLogo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "height"),
    5: .standard(proto: "image_id"),
    6: .same(proto: "url"),
    7: .same(proto: "width"),
    8: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformLogo, rhs: Proto_PlatformLogo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionResult, rhs: Proto_PlatformVersionResult) -> Bool {
    if lhs.platformversions != rhs.platformversions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "companies"),
    3: .same(proto: "connectivity"),
    4: .same(proto: "cpu"),
    5: .same(proto: "graphics"),
    6: .standard(proto: "main_manufacturer"),
    7: .same(proto: "media"),
    8: .same(proto: "memory"),
    9: .same(proto: "name"),
    10: .same(proto: "online"),
    11: .same(proto: "os"),
    12: .same(proto: "output"),
    13: .standard(proto: "platform_logo"),
    14: .standard(proto: "platform_version_release_dates"),
    15: .same(proto: "resolutions"),
    16: .same(proto: "slug"),
    17: .same(proto: "sound"),
    18: .same(proto: "storage"),
    19: .same(proto: "summary"),
    20: .same(proto: "url"),
    21: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _companies: [Proto_PlatformVersionCompany] = []
    var _connectivity: String = String()
    var _cpu: String = String()
    var _graphics: String = String()
    var _mainManufacturer: Proto_PlatformVersionCompany? = nil
    var _media: String = String()
    var _memory: String = String()
    var _name: String = String()
    var _online: String = String()
    var _os: String = String()
    var _output: String = String()
    var _platformLogo: Proto_PlatformLogo? = nil
    var _platformVersionReleaseDates: [Proto_PlatformVersionReleaseDate] = []
    var _resolutions: String = String()
    var _slug: String = String()
    var _sound: String = String()
    var _storage: String = String()
    var _summary: String = String()
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _companies = source._companies
      _connectivity = source._connectivity
      _cpu = source._cpu
      _graphics = source._graphics
      _mainManufacturer = source._mainManufacturer
      _media = source._media
      _memory = source._memory
      _name = source._name
      _online = source._online
      _os = source._os
      _output = source._output
      _platformLogo = source._platformLogo
      _platformVersionReleaseDates = source._platformVersionReleaseDates
      _resolutions = source._resolutions
      _slug = source._slug
      _sound = source._sound
      _storage = source._storage
      _summary = source._summary
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._connectivity) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._cpu) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._graphics) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._mainManufacturer) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._media) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._memory) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._online) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._os) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._output) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._platformLogo) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._platformVersionReleaseDates) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._resolutions) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._sound) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._storage) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._companies, fieldNumber: 2)
      }
      if !_storage._connectivity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectivity, fieldNumber: 3)
      }
      if !_storage._cpu.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cpu, fieldNumber: 4)
      }
      if !_storage._graphics.isEmpty {
        try visitor.visitSingularStringField(value: _storage._graphics, fieldNumber: 5)
      }
      if let v = _storage._mainManufacturer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._media.isEmpty {
        try visitor.visitSingularStringField(value: _storage._media, fieldNumber: 7)
      }
      if !_storage._memory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memory, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if !_storage._online.isEmpty {
        try visitor.visitSingularStringField(value: _storage._online, fieldNumber: 10)
      }
      if !_storage._os.isEmpty {
        try visitor.visitSingularStringField(value: _storage._os, fieldNumber: 11)
      }
      if !_storage._output.isEmpty {
        try visitor.visitSingularStringField(value: _storage._output, fieldNumber: 12)
      }
      if let v = _storage._platformLogo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._platformVersionReleaseDates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._platformVersionReleaseDates, fieldNumber: 14)
      }
      if !_storage._resolutions.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resolutions, fieldNumber: 15)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 16)
      }
      if !_storage._sound.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sound, fieldNumber: 17)
      }
      if !_storage._storage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storage, fieldNumber: 18)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 19)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 20)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersion, rhs: Proto_PlatformVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._connectivity != rhs_storage._connectivity {return false}
        if _storage._cpu != rhs_storage._cpu {return false}
        if _storage._graphics != rhs_storage._graphics {return false}
        if _storage._mainManufacturer != rhs_storage._mainManufacturer {return false}
        if _storage._media != rhs_storage._media {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._os != rhs_storage._os {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._platformLogo != rhs_storage._platformLogo {return false}
        if _storage._platformVersionReleaseDates != rhs_storage._platformVersionReleaseDates {return false}
        if _storage._resolutions != rhs_storage._resolutions {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._sound != rhs_storage._sound {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._summary != rhs_storage._summary {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionCompanyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionCompanyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversioncompanies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversioncompanies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversioncompanies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversioncompanies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionCompanyResult, rhs: Proto_PlatformVersionCompanyResult) -> Bool {
    if lhs.platformversioncompanies != rhs.platformversioncompanies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionCompany: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionCompany"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "comment"),
    3: .same(proto: "company"),
    4: .same(proto: "developer"),
    5: .same(proto: "manufacturer"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._company) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.developer) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.manufacturer) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if let v = self._company {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.developer != false {
      try visitor.visitSingularBoolField(value: self.developer, fieldNumber: 4)
    }
    if self.manufacturer != false {
      try visitor.visitSingularBoolField(value: self.manufacturer, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionCompany, rhs: Proto_PlatformVersionCompany) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs._company != rhs._company {return false}
    if lhs.developer != rhs.developer {return false}
    if lhs.manufacturer != rhs.manufacturer {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionReleaseDateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionReleaseDateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformversionreleasedates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformversionreleasedates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformversionreleasedates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformversionreleasedates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionReleaseDateResult, rhs: Proto_PlatformVersionReleaseDateResult) -> Bool {
    if lhs.platformversionreleasedates != rhs.platformversionreleasedates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformVersionReleaseDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformVersionReleaseDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "date"),
    5: .same(proto: "human"),
    6: .same(proto: "m"),
    7: .standard(proto: "platform_version"),
    8: .same(proto: "region"),
    9: .standard(proto: "updated_at"),
    10: .same(proto: "y"),
    11: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.human) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.m) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._platformVersion) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .yyyymmmmdd {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.human.isEmpty {
      try visitor.visitSingularStringField(value: self.human, fieldNumber: 5)
    }
    if self.m != 0 {
      try visitor.visitSingularInt32Field(value: self.m, fieldNumber: 6)
    }
    if let v = self._platformVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.region != .regionRegionNull {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 8)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 10)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformVersionReleaseDate, rhs: Proto_PlatformVersionReleaseDate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._date != rhs._date {return false}
    if lhs.human != rhs.human {return false}
    if lhs.m != rhs.m {return false}
    if lhs._platformVersion != rhs._platformVersion {return false}
    if lhs.region != rhs.region {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.y != rhs.y {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformWebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformWebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platformwebsites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.platformwebsites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.platformwebsites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.platformwebsites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformWebsiteResult, rhs: Proto_PlatformWebsiteResult) -> Bool {
    if lhs.platformwebsites != rhs.platformwebsites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlatformWebsite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformWebsite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "trusted"),
    4: .same(proto: "url"),
    5: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlatformWebsite, rhs: Proto_PlatformWebsite) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlayerPerspectiveResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayerPerspectiveResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playerperspectives"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.playerperspectives) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playerperspectives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playerperspectives, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlayerPerspectiveResult, rhs: Proto_PlayerPerspectiveResult) -> Bool {
    if lhs.playerperspectives != rhs.playerperspectives {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PlayerPerspective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayerPerspective"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PlayerPerspective, rhs: Proto_PlayerPerspective) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDateResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "releasedates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.releasedates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.releasedates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.releasedates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDateResult, rhs: Proto_ReleaseDateResult) -> Bool {
    if lhs.releasedates != rhs.releasedates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReleaseDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "date"),
    5: .same(proto: "game"),
    6: .same(proto: "human"),
    7: .same(proto: "m"),
    8: .same(proto: "platform"),
    9: .same(proto: "region"),
    10: .standard(proto: "updated_at"),
    11: .same(proto: "y"),
    12: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.human) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.m) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._platform) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .yyyymmmmdd {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.human.isEmpty {
      try visitor.visitSingularStringField(value: self.human, fieldNumber: 6)
    }
    if self.m != 0 {
      try visitor.visitSingularInt32Field(value: self.m, fieldNumber: 7)
    }
    if let v = self._platform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.region != .regionRegionNull {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 9)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 11)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ReleaseDate, rhs: Proto_ReleaseDate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._date != rhs._date {return false}
    if lhs._game != rhs._game {return false}
    if lhs.human != rhs.human {return false}
    if lhs.m != rhs.m {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs.region != rhs.region {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.y != rhs.y {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ScreenshotResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScreenshotResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screenshots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screenshots) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screenshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screenshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScreenshotResult, rhs: Proto_ScreenshotResult) -> Bool {
    if lhs.screenshots != rhs.screenshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Screenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screenshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alpha_channel"),
    3: .same(proto: "animated"),
    4: .same(proto: "game"),
    5: .same(proto: "height"),
    6: .standard(proto: "image_id"),
    7: .same(proto: "url"),
    8: .same(proto: "width"),
    9: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alphaChannel) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.animated) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.alphaChannel != false {
      try visitor.visitSingularBoolField(value: self.alphaChannel, fieldNumber: 2)
    }
    if self.animated != false {
      try visitor.visitSingularBoolField(value: self.animated, fieldNumber: 3)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.imageID.isEmpty {
      try visitor.visitSingularStringField(value: self.imageID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 8)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Screenshot, rhs: Proto_Screenshot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.alphaChannel != rhs.alphaChannel {return false}
    if lhs.animated != rhs.animated {return false}
    if lhs._game != rhs._game {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.width != rhs.width {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SearchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "searches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.searches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SearchResult, rhs: Proto_SearchResult) -> Bool {
    if lhs.searches != rhs.searches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Search"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "alternative_name"),
    3: .same(proto: "character"),
    4: .same(proto: "collection"),
    5: .same(proto: "company"),
    6: .same(proto: "description"),
    7: .same(proto: "game"),
    8: .same(proto: "name"),
    9: .same(proto: "platform"),
    10: .standard(proto: "published_at"),
    11: .standard(proto: "test_dummy"),
    12: .same(proto: "theme"),
    13: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _alternativeName: String = String()
    var _character: Proto_Character? = nil
    var _collection: Proto_Collection? = nil
    var _company: Proto_Company? = nil
    var _description_p: String = String()
    var _game: Proto_Game? = nil
    var _name: String = String()
    var _platform: Proto_Platform? = nil
    var _publishedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _testDummy: Proto_TestDummy? = nil
    var _theme: Proto_Theme? = nil
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _alternativeName = source._alternativeName
      _character = source._character
      _collection = source._collection
      _company = source._company
      _description_p = source._description_p
      _game = source._game
      _name = source._name
      _platform = source._platform
      _publishedAt = source._publishedAt
      _testDummy = source._testDummy
      _theme = source._theme
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._alternativeName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._character) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._collection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._company) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._platform) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._publishedAt) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._testDummy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._alternativeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._alternativeName, fieldNumber: 2)
      }
      if let v = _storage._character {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._collection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._company {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 8)
      }
      if let v = _storage._platform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._publishedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._testDummy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Search, rhs: Proto_Search) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._alternativeName != rhs_storage._alternativeName {return false}
        if _storage._character != rhs_storage._character {return false}
        if _storage._collection != rhs_storage._collection {return false}
        if _storage._company != rhs_storage._company {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._publishedAt != rhs_storage._publishedAt {return false}
        if _storage._testDummy != rhs_storage._testDummy {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TestDummyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestDummyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "testdummies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.testdummies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.testdummies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testdummies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TestDummyResult, rhs: Proto_TestDummyResult) -> Bool {
    if lhs.testdummies != rhs.testdummies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TestDummy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestDummy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "bool_value"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "enum_test"),
    5: .standard(proto: "float_value"),
    6: .same(proto: "game"),
    7: .standard(proto: "integer_array"),
    8: .standard(proto: "integer_value"),
    9: .same(proto: "name"),
    10: .standard(proto: "new_integer_value"),
    11: .same(proto: "private"),
    12: .same(proto: "slug"),
    13: .standard(proto: "string_array"),
    14: .standard(proto: "test_dummies"),
    15: .standard(proto: "test_dummy"),
    16: .standard(proto: "updated_at"),
    17: .same(proto: "url"),
    18: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _boolValue: Bool = false
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _enumTest: Proto_TestDummyEnumTestEnum = .testdummyEnumTestNull
    var _floatValue: Double = 0
    var _game: Proto_Game? = nil
    var _integerArray: [Int32] = []
    var _integerValue: Int32 = 0
    var _name: String = String()
    var _newIntegerValue: Int32 = 0
    var _private: Bool = false
    var _slug: String = String()
    var _stringArray: [String] = []
    var _testDummies: [Proto_TestDummy] = []
    var _testDummy: Proto_TestDummy? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _url: String = String()
    var _checksum: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _boolValue = source._boolValue
      _createdAt = source._createdAt
      _enumTest = source._enumTest
      _floatValue = source._floatValue
      _game = source._game
      _integerArray = source._integerArray
      _integerValue = source._integerValue
      _name = source._name
      _newIntegerValue = source._newIntegerValue
      _private = source._private
      _slug = source._slug
      _stringArray = source._stringArray
      _testDummies = source._testDummies
      _testDummy = source._testDummy
      _updatedAt = source._updatedAt
      _url = source._url
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._enumTest) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._floatValue) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._game) }()
        case 7: try { try decoder.decodeRepeatedInt32Field(value: &_storage._integerArray) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._integerValue) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._newIntegerValue) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._private) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._stringArray) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._testDummies) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._testDummy) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._boolValue != false {
        try visitor.visitSingularBoolField(value: _storage._boolValue, fieldNumber: 2)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._enumTest != .testdummyEnumTestNull {
        try visitor.visitSingularEnumField(value: _storage._enumTest, fieldNumber: 4)
      }
      if _storage._floatValue != 0 {
        try visitor.visitSingularDoubleField(value: _storage._floatValue, fieldNumber: 5)
      }
      if let v = _storage._game {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._integerArray.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._integerArray, fieldNumber: 7)
      }
      if _storage._integerValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._integerValue, fieldNumber: 8)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if _storage._newIntegerValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._newIntegerValue, fieldNumber: 10)
      }
      if _storage._private != false {
        try visitor.visitSingularBoolField(value: _storage._private, fieldNumber: 11)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 12)
      }
      if !_storage._stringArray.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._stringArray, fieldNumber: 13)
      }
      if !_storage._testDummies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testDummies, fieldNumber: 14)
      }
      if let v = _storage._testDummy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 17)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TestDummy, rhs: Proto_TestDummy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._enumTest != rhs_storage._enumTest {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._game != rhs_storage._game {return false}
        if _storage._integerArray != rhs_storage._integerArray {return false}
        if _storage._integerValue != rhs_storage._integerValue {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._newIntegerValue != rhs_storage._newIntegerValue {return false}
        if _storage._private != rhs_storage._private {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._stringArray != rhs_storage._stringArray {return false}
        if _storage._testDummies != rhs_storage._testDummies {return false}
        if _storage._testDummy != rhs_storage._testDummy {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThemeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThemeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "themes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.themes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.themes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.themes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThemeResult, rhs: Proto_ThemeResult) -> Bool {
    if lhs.themes != rhs.themes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Theme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Theme"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "name"),
    4: .same(proto: "slug"),
    5: .standard(proto: "updated_at"),
    6: .same(proto: "url"),
    7: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.slug) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.slug.isEmpty {
      try visitor.visitSingularStringField(value: self.slug, fieldNumber: 4)
    }
    if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Theme, rhs: Proto_Theme) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.slug != rhs.slug {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WebsiteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebsiteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "websites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.websites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.websites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.websites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_WebsiteResult, rhs: Proto_WebsiteResult) -> Bool {
    if lhs.websites != rhs.websites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Website: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Website"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "game"),
    4: .same(proto: "trusted"),
    5: .same(proto: "url"),
    6: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._game) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.category != .websiteCategoryNull {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    if let v = self._game {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Website, rhs: Proto_Website) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs._game != rhs._game {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.url != rhs.url {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
